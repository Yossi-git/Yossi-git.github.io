<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>丽江6日游</title>
    <link href="/2020/08/03/15:24.html"/>
    <url>/2020/08/03/15:24.html</url>
    
    <content type="html"><![CDATA[<h1 id="暂定计划路线"><a href="#暂定计划路线" class="headerlink" title="暂定计划路线"></a>暂定计划路线</h1><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200803220933.jpeg" srcset="/img/loading.gif" alt="IMG_2199"></p><p>六日游玩时间，主要目的地<code>洱海</code>、<code>丽江古城</code>、<code>玉龙雪山和蓝月谷</code>、<code>香格里拉</code>，地方少点不那么累，也有很多时间慢慢欣赏风景（主要还是穷）；</p><h2 id="整体计划"><a href="#整体计划" class="headerlink" title="整体计划:"></a>整体计划:</h2><ul><li><p>Day1:丽江游玩一天，在丽江的客栈住一晚，第二天出发去雪山;</p></li><li><p>Day2:雪山+蓝月谷玩一天，晚上回丽江逛逛然后去大理住宿（300/人）；</p></li><li><p>Day3:洱海租车玩一天；</p></li><li><p>Day4:预留一天到时候灵活安排；</p></li><li><p>Day5:一早出发去香格里拉，在香格里拉住一晚次日早上回大理；</p></li><li><p>Day6:看看你有没有想去的地方再定；</p></li><li><p>Day7:回家</p></li></ul><h2 id="预计开销："><a href="#预计开销：" class="headerlink" title="预计开销："></a>预计开销：</h2><p>住宿（目前未知）+往返机票（预计1100左右）+景点游玩费（丽江预计300+洱海预计300+雪山315+香格里拉610）=是不是预估的优点高（3000元总共）</p><h2 id="详细计划："><a href="#详细计划：" class="headerlink" title="详细计划："></a>详细计划：</h2><h3 id="丽江古城、洱海–选择自由行（开销无法计算）；"><a href="#丽江古城、洱海–选择自由行（开销无法计算）；" class="headerlink" title="丽江古城、洱海–选择自由行（开销无法计算）；"></a>丽江古城、洱海–选择自由行（开销无法计算）；</h3><p>1、丽江古城第一站</p><ul><li>这里你熟悉你带路了</li></ul><p>2、洱海第三站</p><ul><li>就想看看海，听说有甲壳虫车，可以租一个开着环海玩；</li><li>路线：洱海–&gt;花语牧场–&gt;双廊古镇</li></ul><h3 id="雪山-蓝月谷–跟小团或者自由行；"><a href="#雪山-蓝月谷–跟小团或者自由行；" class="headerlink" title="雪山+蓝月谷–跟小团或者自由行；"></a>雪山+蓝月谷–跟小团或者自由行；</h3><ol><li>小团一日纯游玩（400/人）</li></ol><ul><li>包来回接送和午饭，价格普遍在400以上，说的是不催你，想玩多久玩多久，你决定要不要跟团，需要的话可以提前预定，也可以到了丽江再跟；</li></ul><ol start="2"><li><p>自由行（315人）：</p><ul><li><p>整体路线：<code>丽江大巴直通车--&gt;提前30分钟排队检查健康码--&gt;租衣坐缆车--&gt;爬山看风景--&gt;下山坐缆车--&gt;排队等车去蓝月谷--&gt;坐大巴回景区门口--&gt;坐旅游巴士回丽江古城</code></p></li><li><p>门票价格50（包含雪山和蓝月谷），提前两三天开始抢购，早上7点开始抢购（微信小程序：丽江旅游集团）建议额外选择花费<code>#冰川公园索道票140+观光车票20</code>雪山少运动，高反会很难受；</p></li><li><p><code>交通</code>：丽江古城的忠义市场有<code>雪山专线</code>车程50分钟，价格15元；打车的话目的地一定选择<code>雪厨餐厅</code>，不然到不了雪山，晚上返回古城的大巴最晚时间是<code>17:10</code> 发车；夏天几乎没多少雪不是很冷，主要看冰川，可以自己带长袖就够，羽绒服租借50/人，押金200；氧气最好网上购买邮寄到住处，或者在丽江的一些药店购买，景区购买昂贵且杂牌。</p></li><li><p><code>蓝月谷</code>：雪山玩了后坐缆车下山直接排队坐到<code>水月阁</code>下车，中途千万不要提前下车。</p></li><li><p><code>午饭不知道哪儿吃，这个后面要提前找找</code>，也可以自己带点零食；</p></li><li><p>总费用：来回大巴30+门票50+索道140+观光车20+氧气瓶25+（羽绒服50）=265（315）</p></li></ul></li></ol><h3 id="香格里拉–跟2日纯玩小团或者自由行"><a href="#香格里拉–跟2日纯玩小团或者自由行" class="headerlink" title="香格里拉–跟2日纯玩小团或者自由行"></a>香格里拉–跟2日纯玩小团或者自由行</h3><p>主要景点有：独克宗古城（免费）、松赞林寺（90/人）、普达措国家公园（需要从香格里拉搭车去来回车费120/人，门票100/人）、纳帕海草原（特美还人少，可以租电瓶车环海骑行）</p><ol><li>2日团：价格一般在590左右，包一晚住宿和吃饭；</li><li>自由行（650元左右）：<ul><li>路线：<code>大理一早出发--&gt;纳帕海草原--&gt;松赞林寺--&gt;独克宗古城--&gt;普达措公园（暂定）--&gt;次日早上回大理</code></li><li>交通：丽江–&gt;香格里拉的班车（7:30–17:30），3个小时车程；大理北客站–&gt;香格里拉（7:45–15:00）车程3小时45分，费用114元，多为山路容易晕车记得吃点晕车药，以免晕车影响游玩；</li><li>纳帕海草原：吃了午饭差不多就可以去这一站，不要进景区，景区外更美，租个电动车，环湖公园路–&gt;石卡路–&gt;环湖路，全程50Km，4个小时能走完；</li><li>松赞林寺：纳帕海骑行回来的路上就可以路过，记得导航到景区入口，不然进不去，门票含有导游，建议跟随导游一路走；</li><li>独克宗古城：日出日落特别美，还可以俯瞰整个古城，一天结束去看看日落，第二天时间来得及还可以看看日出再回大理；</li><li>普达措公园：二日行就第二天去，距离市区较远，建议包车或者包一个小团去，目前看了下小红书的景点不是很美，而且是爬山还会有高反，感觉不是很值得去；</li><li>吃住：当地特色牦牛肉和酥油茶，美团购买物价不是很高，可以住在当地的民宿（提前预订好）；</li><li>总计费用：往返车票228元+电动车（？）+松赞林寺（90）+吃饭住宿200=650元左右</li></ul></li></ol><h2 id="机票方案"><a href="#机票方案" class="headerlink" title="机票方案"></a>机票方案</h2><h3 id="最近一个月机票价格"><a href="#最近一个月机票价格" class="headerlink" title="最近一个月机票价格"></a>最近一个月机票价格</h3><p><code>成都--&gt;昆明--&gt;丽江</code></p><p>成都到昆明的机票是所有计划最便宜的，航班时间集中在<code>22:55--00:30</code> 这个时间段，加上<code>昆明--&gt;丽江</code>的<code>动车</code> <code>220元</code>3小时车程，整体价格比直达丽江贵，路途时间也更久。</p><p><code>成都--&gt;丽江</code></p><p>目前只有6号价格最低470元（420+50）航班时间<code>5:40--7:15</code>，11号和后面的日子都是需要去西安转机，并且中间要停留一晚。如果要6号走的话，这两天就需要确定好行程计划，时间感觉会很紧张。</p><img src="https://gitee.com/yossi/picture/raw/master/img/20200803200601.jpeg" srcset="/img/loading.gif" style="zoom:50%;"><p><code>重庆--&gt;丽江</code> </p><p>整体价格450之内，10号最低票价433（383+50），航班时间段在<code>6:25--8:10</code>，如果选择重庆飞的话，你就需要前一天坐动车<code>2个半小时</code>，票价100–121；高铁<code>一个半小时</code>,票价140–150；动车主要在上午<code>成都东--&gt;重庆北</code>，高铁主要在下午<code>成都东--&gt;重庆西</code>，还可以在重庆逛逛夜景，重庆夜景很好看，不想这么绕的话，那就成都直达。</p> <img src="https://gitee.com/yossi/picture/raw/master/img/20200803200614.jpeg" srcset="/img/loading.gif" style="zoom:50%;"><p>目前写到这么多，明天继续查查攻略再修改；</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>批量删除QQ空间说说的JS脚本</title>
    <link href="/2020/07/16/20:24.html"/>
    <url>/2020/07/16/20:24.html</url>
    
    <content type="html"><![CDATA[<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>这个脚本是从当前页开始删除说说，自动跳转<code>下一页</code>，所以先去需要删除的起始页，再点击<code>删除所有说说按钮</code>，如果使用<code>自动跳转到说说标签</code>会从第一页开始删除，请确认好删除的范围，不然删掉了就找不回来了。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>建议使用谷歌的<code>chrome</code>浏览器，进入到空间的说说页面，按键盘的<code>F12</code>，点击进入<code>console</code>控制台，把下面的代码复制进去，回车运行。</p><div class="hljs"><pre><code class="hljs js">addFloatButton(<span class="hljs-string">'删除所有说说'</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">this</span>.loop = !<span class="hljs-keyword">this</span>.loop<span class="hljs-keyword">const</span> appIframe = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.app_canvas_frame'</span>)<span class="hljs-keyword">if</span> (!appIframe) &#123;    <span class="hljs-keyword">const</span> switchToTag = <span class="hljs-built_in">window</span>.confirm(<span class="hljs-string">'未切换到“说说”标签，是否立即切换？'</span>)    <span class="hljs-keyword">if</span> (switchToTag) &#123;<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'head-nav-menu&gt;.menu_item_311&gt;a'</span>).click()    &#125;     <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">return</span>    &#125;  &#125;  <span class="hljs-keyword">const</span> iframeDocument = appIframe.contentWindow.document  <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.loop) &#123;    clickAllEl(<span class="hljs-string">'.del_btn'</span>, iframeDocument)    <span class="hljs-keyword">await</span> sleepAsync(<span class="hljs-number">500</span>) <span class="hljs-comment">//点击删除，延迟500ms</span>    clickAllEl(<span class="hljs-string">'.qz_dialog_layer_sub'</span>)    <span class="hljs-keyword">await</span> sleepAsync(<span class="hljs-number">1500</span>)<span class="hljs-comment">//点击确定，延迟500ms</span>    nextPage()   <span class="hljs-keyword">await</span> sleepAsync(<span class="hljs-number">3000</span>)<span class="hljs-comment">//翻页延迟3s，这个延迟最低2s，不然会跳页</span>  &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextPage</span> (<span class="hljs-params"></span>) </span>&#123;    iframeDocument.querySelectorAll(<span class="hljs-string">'.mod_pagenav_main&gt;a'</span>).forEach(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> &#123;      <span class="hljs-keyword">if</span> (el.innerText === <span class="hljs-string">'下一页'</span>) &#123;        el.click()      &#125;    &#125;)  &#125;&#125;)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickAllEl</span> (<span class="hljs-params">selector, parentNode = document</span>) </span>&#123;  parentNode.querySelectorAll(selector).forEach(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.click())&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleepAsync</span> (<span class="hljs-params">time</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> setTimeout(resolve, time))&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addFloatButton</span> (<span class="hljs-params">text, onclick</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">document</span>.addFloatButton) &#123;    <span class="hljs-keyword">const</span> buttonContainer = <span class="hljs-built_in">document</span>.body        .appendChild(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>))        .attachShadow(&#123; <span class="hljs-attr">mode</span>: <span class="hljs-string">'open'</span> &#125;)        buttonContainer.innerHTML = <span class="hljs-string">'&lt;style&gt;\</span><span class="hljs-string">        :host&#123;position:fixed;\</span><span class="hljs-string">        top:3px;\</span><span class="hljs-string">        left:3px;\</span><span class="hljs-string">        z-index:2147483647;height:0&#125;\</span><span class="hljs-string">        #i&#123;display:none&#125;\</span><span class="hljs-string">            *&#123;float:left;\</span><span class="hljs-string">              margin:4px;\</span><span class="hljs-string">              padding:1em;\</span><span class="hljs-string">              outline:0;\</span><span class="hljs-string">              border:0;\</span><span class="hljs-string">              border-radius:5px;\</span><span class="hljs-string">              background:#1e88e5;\</span><span class="hljs-string">              box-shadow:0 1px 4pxrgba(0,0,0,.1);\</span><span class="hljs-string">      color:#fff;\</span><span class="hljs-string">              font-size:14px;\</span><span class="hljs-string">      line-height:0;\</span><span class="hljs-string">      transition:.3s&#125;:active&#123;background:#42a5f5;\</span><span class="hljs-string">                box-shadow:0 2px 5px rgba(0,0,0,.2)\</span><span class="hljs-string">              &#125;\</span><span class="hljs-string">button:active&#123;\</span><span class="hljs-string">        transition:0s&#125;:checked~button&#123;\</span><span class="hljs-string">                    visibility:hidden;\</span><span class="hljs-string">                    opacity:0;\</span><span class="hljs-string">                    transform:translateY(-3em)\</span><span class="hljs-string">                &#125;\</span><span class="hljs-string">label&#123;\</span><span class="hljs-string">                    border-radius:50%\</span><span class="hljs-string">                &#125;\</span><span class="hljs-string">                :checked~label&#123;\</span><span class="hljs-string">                opacity:.3;\</span><span class="hljs-string">                    transform:translateY(3em)\</span><span class="hljs-string">                &#125;\</span><span class="hljs-string">                &lt;/style&gt;&lt;input id=i type=checkbox&gt;&lt;label for=i&gt;&lt;/label&gt;'</span>           <span class="hljs-built_in">document</span>.addFloatButton = <span class="hljs-function">(<span class="hljs-params">text, onclick</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> button = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'button'</span>)      button.textContent = text      button.addEventListener(<span class="hljs-string">'click'</span>, onclick)      <span class="hljs-keyword">return</span> buttonContainer.appendChild(button)    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.addFloatButton(text, onclick)&#125;</code></pre></div><p>在页面的左上角会出现这样的图标按钮：</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200717180339.png" srcset="/img/loading.gif" alt="image-20200717180133961"></p><p>圆圈是<code>隐藏</code>和<code>显示</code>后面<code>“删除所有说说”</code>功能按钮的作用；</p><p>点击一次<code>“删除所有说说”</code>开始运行脚本，会自动进行删除说说操作，不需要你去点击页面的确认按钮，这个运行速度可以调整，在代码注释里有标记。</p><p>再次点击<code>“删除所有说说”</code>按钮，立刻停止脚本运行。</p><p>删除几十页后会弹出验证码，这个时候就不能再删了，需要等待一个小时后再来。</p>]]></content>
    
    
    <categories>
      
      <category>脚本工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写给大忙人看的操作系统</title>
    <link href="/2020/07/13/15:24.html"/>
    <url>/2020/07/13/15:24.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p><strong>来源公众号：Java建设者</strong></p><p><strong>作者：cxuan</strong></p>          </div> <p>文章主要结构图如下</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714163102.jpeg" srcset="/img/loading.gif" alt="img"></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>现代计算机系统由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133625.jpeg" srcset="/img/loading.gif" alt="img"></p><p>然而，程序员不会直接和这些硬件打交道，而且每位程序员不可能会掌握所有计算机系统的细节，这样我们就不用再编写代码了，所以在硬件的基础之上，计算机安装了一层软件，这层软件能够通过响应用户输入的指令达到控制硬件的效果，从而满足用户需求，这种软件称之为 <code>操作系统</code>，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。</p><p>我们一般常见的操作系统主要有 <strong>Windows、Linux、FreeBSD 或 OS X</strong> ，这种带有图形界面的操作系统被称为 <code>图形用户界面(Graphical User Interface, GUI)</code>，而基于文本、命令行的通常称为 <code>Shell</code>。下面是我们所要探讨的操作系统的部件</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133619.png" srcset="/img/loading.gif" alt="img"></p><p>这是一个操作系统的简化图，最下面的是硬件，硬件包括芯片、电路板、磁盘、键盘、显示器等我们上面提到的设备，在硬件之上是软件。大部分计算机有两种运行模式：<code>内核态</code> 和 <code>用户态</code>，软件中最基础的部分是<code>操作系统</code>，它运行在 <code>内核态</code> 中，内核态也称为 <code>管态</code> 和 <code>核心态</code>，它们都是操作系统的运行状态，只不过是不同的叫法而已。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 <code>用户态</code> 下。</p><p><code>用户接口程序(shell 或者 GUI)</code>处于用户态中，并且它们位于用户态的最低层，允许用户运行其他程序，例如 Web 浏览器、电子邮件阅读器、音乐播放器等。而且，越靠近用户态的应用程序越容易编写，如果你不喜欢某个电子邮件阅读器你可以重新写一个或者换一个，但你不能自行写一个操作系统或者是中断处理程序。这个程序由硬件保护，防止外部对其进行修改。</p><h2 id="计算机硬件简介"><a href="#计算机硬件简介" class="headerlink" title="计算机硬件简介"></a>计算机硬件简介</h2><p>操作系统与运行操作系统的内核硬件关系密切。操作系统扩展了计算机指令集并管理计算机的资源。因此，操作系统因此必须足够了解硬件的运行，这里我们先简要介绍一下现代计算机中的计算机硬件。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133614.jpeg" srcset="/img/loading.gif" alt="img"></p><p>从概念上来看，一台简单的个人电脑可以被抽象为上面这种相似的模型，CPU、内存、I/O 设备都和总线串联起来并通过总线与其他设备进行通信。现代操作系统有着更为复杂的结构，会设计很多条总线，我们稍后会看到。暂时来讲，这个模型能够满足我们的讨论。</p><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>CPU 是计算机的大脑，它主要和内存进行交互，从内存中提取指令并执行它。一个 CPU 的执行周期是从内存中提取第一条指令、解码并决定它的类型和操作数，执行，然后再提取、解码执行后续的指令。重复该循环直到程序运行完毕。</p><p>每个 CPU 都有一组可以执行的特定指令集。因此，x86 的 CPU 不能执行 ARM 的程序并且 ARM 的 CPU 也不能执行 x86 的程序。由于访问内存获取执行或数据要比执行指令花费的时间长，因此所有的 CPU 内部都会包含一些<code>寄存器</code>来保存关键变量和临时结果。因此，在指令集中通常会有一些指令用于把关键字从内存中加载到寄存器中，以及把关键字从寄存器存入到内存中。还有一些其他的指令会把来自寄存器和内存的操作数进行组合，例如 add 操作就会把两个操作数相加并把结果保存到内存中。</p><p>除了用于保存变量和临时结果的通用寄存器外，大多数计算机还具有几个特殊的寄存器，这些寄存器对于程序员是可见的。其中之一就是 <code>程序计数器(program counter)</code>，程序计数器会指示下一条需要从内存提取指令的地址。提取指令后，程序计数器将更新为下一条需要提取的地址。</p><p>另一个寄存器是 <code>堆栈指针(stack pointer)</code>，它指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。</p><p>还有一个寄存器是 <code>PSW(Program Status Word)</code> 程序状态字寄存器，这个寄存器是由操作系统维护的8个字节(64位) long 类型的数据集合。它会跟踪当前系统的状态。除非发生系统结束，否则我们可以忽略 PSW 。用户程序通常可以读取整个PSW，但通常只能写入其某些字段。PSW 在系统调用和 I / O 中起着重要作用。</p><p>操作系统必须了解所有的寄存器。在<code>时间多路复用(time multiplexing)</code> 的 CPU 中，操作系统往往停止运行一个程序转而运行另外一个。每次当操作系统停止运行一个程序时，操作系统会保存所有寄存器的值，以便于后续重新运行该程序。</p><p>为了提升性能， CPU 设计人员早就放弃了同时去读取、解码和执行一条简单的指令。许多现代的 CPU 都具有同时读取多条指令的机制。例如，一个 CPU 可能会有单独访问、解码和执行单元，所以，当 CPU 执行第 N 条指令时，还可以对 N + 1 条指令解码，还可以读取 N + 2 条指令。像这样的组织形式被称为 <code>流水线(pipeline)。</code></p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133608.png" srcset="/img/loading.gif" alt="img"></p><p>比流水线更先进的设计是 <code>超标量(superscalar)</code>CPU，下面是超标量 CPU 的设计</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133603.jpeg" srcset="/img/loading.gif" alt="img"></p><p>在上面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或者更多的指令被一次性取出、解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出并执行。这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。</p><p>除了用在嵌入式系统中非常简单的 CPU 之外，多数 CPU 都有<code>两种模式</code>，即前面已经提到的内核态和用户态。通常情况下，<code>PSW 寄存器</code>中的一个二进制位会控制当前状态是内核态还是用户态。当运行在内核态时，CPU 能够执行任何指令集中的指令并且能够使用硬件的功能。在台式机和服务器上，操作系统通常以内核模式运行，从而可以访问完整的硬件。在大多数嵌入式系统中，一部分运行在内核态下，剩下的一部分运行在用户态下。</p><p>用户应用程序通常运行在用户态下，在用户态下，CPU 只能执行指令集中的一部分并且只能访问硬件的一部分功能。一般情况下，在用户态下，有关 I/O 和内存保护的所有指令是禁止执行的。当然，设置 PSW 模式的二进制位为内核态也是禁止的。</p><p>为了获取操作系统的服务，用户程序必须使用 <code>系统调用(system call)</code>，系统调用会转换为内核态并且调用操作系统。<code>TRAP</code> 指令用于把用户态切换为内核态并启用操作系统。当有关工作完成之后，在系统调用后面的指令会把控制权交给用户程序。我们会在后面探讨操作系统的调用细节。</p><p>需要注意的是操作系统在进行系统调用时会存在陷阱。大部分的陷阱会导致硬件发出警告，比如说试图被零除或浮点下溢等你。在所有的情况下，操作系统都能得到控制权并决定如何处理异常情况。有时，由于出错的原因，程序不得不停止。</p><h3 id="多线程和多核芯片"><a href="#多线程和多核芯片" class="headerlink" title="多线程和多核芯片"></a>多线程和多核芯片</h3><p>Intel Pentinum 4也就是奔腾处理器引入了被称为<code>多线程(multithreading)</code> 或 <code>超线程(hyperthreading, Intel 公司的命名)</code> 的特性，x86 处理器和其他一些 CPU 芯片就是这样做的。包括 <strong>SSPARC、Power5、Intel Xeon 和 Intel Core 系列</strong> 。近似地说，多线程允许 CPU 保持两个不同的线程状态并且在<code>纳秒级(nanosecond)</code> 的时间完成切换。线程是一种轻量级的进程，我们会在后面说到。例如，如果一个进程想要从内存中读取指令(这通常会经历几个时钟周期)，多线程 CPU 则可以切换至另一个线程。多线程不会提供真正的并行处理。在一个时刻只有一个进程在运行。</p><p>对于操作系统来讲，多线程是有意义的，因为每个线程对操作系统来说都像是一个单个的 CPU。比如一个有两个 CPU 的操作系统，并且每个 CPU 运行两个线程，那么这对于操作系统来说就可能是 4 个 CPU。</p><p>除了多线程之外，现在许多 CPU 芯片上都具有四个、八个或更多完整的处理器或内核。多核芯片在其上有效地承载了四个微型芯片，每个微型芯片都有自己的独立CPU。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133558.png" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133554.png" srcset="/img/loading.gif" alt="img"></p><p>如果要说在绝对核心数量方面，没有什么能赢过现代 <code>GPU(Graphics Processing Unit)</code>，GPU 是指由成千上万个微核组成的处理器。它们擅长处理大量并行的简单计算。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>计算机中第二个主要的组件就是内存。理想情况下，内存应该非常快速(比执行一条指令要快，从而不会拖慢 CPU 执行效率)，而且足够大且便宜，但是目前的技术手段无法满足三者的需求。于是采用了不同的处理方式，存储器系统采用一种分层次的结构</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133548.png" srcset="/img/loading.gif" alt="img"></p><p>顶层的存储器速度最高，但是容量最小，成本非常高，层级结构越向下，其访问效率越慢，容量越大，但是造价也就越便宜。</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>存储器的顶层是 CPU 中的<code>寄存器</code>，它们用和 CPU 一样的材料制成，所以和 CPU 一样快。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）</p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>位于寄存器下面的是<code>高速缓存</code>，它多数由硬件控制。主存被分割成<code>高速缓存行(cache lines)</code> 为 64 字节，内存地址的 0 - 63 对应高速缓存行 0 ，地址 64 - 127 对应高速缓存行的 1，等等。使用最频繁的高速缓存行保存在位于 CPU 内部或非常靠近 CPU 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是<code>高速缓存命中(cache hit)</code>。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。</p><p>缓存在计算机很多领域都扮演了非常重要的角色，不仅仅是 RAM 缓存行。</p><blockquote><p>“</p><p>随机存储器（RAM）：内存中最重要的一种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会 <code>丢失</code>。</p></blockquote><p>大量的可用资源被划分为小的部分，这些可用资源的一部分会获得比其他资源更频繁的使用权，缓存经常用来提升性能。操作系统无时无刻的不在使用缓存。例如，大多数操作系统在主机内存中保留（部分）频繁使用的文件，以避免重复从磁盘重复获取。举个例子，类似于 <code>/home/ast/projects/minix3/src/kernel/clock.c</code> 这样的场路径名转换成的文件所在磁盘地址的结果也可以保存缓存中，以避免重复寻址。另外，当一个 Web 页面(URL) 的地址转换为网络地址(IP地址)后，这个转换结果也可以缓存起来供将来使用。</p><p>在任何缓存系统中，都会有下面这几个噬需解决的问题</p><ul><li>何时把新的内容放进缓存</li><li>把新的内容应该放在缓存的哪一行</li><li>在需要空闲空间时，应该把哪块内容从缓存中移除</li><li>应该把移除的内容放在某个较大存储器的何处</li></ul><p>并不是每个问题都与每种缓存情况有关。对于 CPU 缓存中的主存缓存行，当有缓存未命中时，就会调入新的内容。通常通过所引用内存地址的高位计算应该使用的缓存行。</p><p>缓存是解决问题的一种好的方式，所以现代 CPU 设计了两种缓存。第一级缓存或者说是 <code>L1 cache</code> 总是位于 CPU 内部，<strong>用来将已解码的指令调入 CPU 的执行引擎</strong>。对于那些频繁使用的关键字，多数芯片有第二个 L1 cache 。典型的 L1 cache 的大小为 16 KB。另外，往往还设有二级缓存，也就是 <code>L2 cache</code>，用来存放最近使用过的关键字，一般是兆字节为单位。L1 cache 和 L2 cache 最大的不同在于是否存在延迟。访问 L1 cache 没有任何的延迟，然而访问 L2 cache 会有 1 - 2 个时钟周期的延后。</p><blockquote><p>“</p><p>什么是时钟周期？计算机处理器或 CPU 的速度由时钟周期来确定，该时钟周期是振荡器两个脉冲之间的时间量。一般而言，每秒脉冲数越高，计算机处理器处理信息的速度就越快。时钟速度以 Hz 为单位测量，通常为兆赫（MHz）或千兆赫（GHz）。例如，一个4 GHz处理器每秒执行4,000,000,000个时钟周期。</p><p>计算机处理器可以在每个时钟周期执行一条或多条指令，这具体取决于处理器的类型。早期的计算机处理器和较慢的 CPU 在每个时钟周期只能执行一条指令，而现代处理器在每个时钟周期可以执行多条指令。</p></blockquote><h4 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h4><p>在上面的层次结构中再下一层是<code>主存</code>，这是内存系统的主力军，主存通常叫做 <code>RAM(Random Access Memory)</code>，由于 1950 年代和 1960 年代的计算机使用微小的可磁化铁氧体磁芯作为主存储器，因此旧时有时将其称为核心存储器。所有不能再高速缓存中得到满足的内存访问请求都会转往主存中。</p><p>除了主存之外，许多计算机还具有少量的非易失性随机存取存储器。它们与 RAM 不同，在电源断电后，非易失性随机访问存储器并不会丢失内容。<code>ROM(Read Only Memory)</code> 中的内容一旦存储后就不会再被修改。它非常快而且便宜。（如果有人问你，有没有什么又快又便宜的内存设备，那就是 ROM 了）在计算机中，用于启动计算机的引导加载模块（也就是 bootstrap ）就存放在 ROM 中。另外，一些 I/O 卡也采用 ROM 处理底层设备控制。</p><p><code>EEPROM(Electrically Erasable PROM,)</code> 和 <code>闪存(flash memory)</code> 也是非易失性的，但是与 ROM 相反，它们可以擦除和重写。不过重写它们需要比写入 RAM 更多的时间，所以它们的使用方式与 ROM 相同，但是与 ROM 不同的是他们可以通过重写字段来纠正程序中出现的错误。</p><p>闪存也通常用来作为便携性的存储媒介。闪存是数码相机中的胶卷，是便携式音乐播放器的磁盘。闪存的速度介于 RAM 和磁盘之间。另外，与磁盘存储器不同的是，如果闪存擦除的次数太多，会出现磨损。</p><p>还有一类是 CMOS，它是易失性的。许多计算机都会使用 CMOS 存储器保持当前时间和日期。</p><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>下一个层次是<code>磁盘(硬盘)</code>，磁盘同 RAM 相比，每个二进制位的成本低了两个数量级，而且经常也有两个数量级大的容量。磁盘唯一的问题是随机访问数据时间大约慢了三个数量级。磁盘访问慢的原因是因为磁盘的构造不同</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133541.jpeg" srcset="/img/loading.gif" alt="img"></p><p>磁盘是一种机械装置，在一个磁盘中有一个或多个金属盘片，它们以 5400rpm、7200rpm、10800rpm 或更高的速度旋转。从边缘开始有一个机械臂悬横在盘面上，这类似于老式播放塑料唱片 33 转唱机上的拾音臂。信息会写在磁盘一系列的同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为<code>磁道(track)</code>。把一个给定臂的位置上的所有磁道合并起来，组成了一个<code>柱面(cylinder)</code>。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133536.jpeg" srcset="/img/loading.gif" alt="img"></p><p>每个磁道划分若干扇区，扇区的值是 512 字节。在现代磁盘中，较外部的柱面比较内部的柱面有更多的扇区。机械臂从一个柱面移动到相邻的柱面大约需要 1ms。而随机移到一个柱面的典型时间为 5ms 至 10ms，具体情况以驱动器为准。一旦磁臂到达正确的磁道上，驱动器必须等待所需的扇区旋转到磁头之下，就开始读写，低端硬盘的速率是<code>50MB/s</code>，而高速磁盘的速率是 <code>160MB/s</code>。</p><blockquote><p>“</p><p>需要注意，<code>固态硬盘(Solid State Disk, SSD)</code>不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在<code>存储器（闪存）</code>中，与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。</p></blockquote><p>许多计算机支持一种著名的<code>虚拟内存</code>机制，这种机制使得期望运行的存储空间大于实际的物理存储空间。其方法是将程序放在磁盘上，而将主存作为一部分缓存，用来保存最频繁使用的部分程序，这种机制需要快速映像内存地址，用来把程序生成的地址转换为有关字节在 RAM 中的物理地址。这种映像由 CPU 中的一个称为 <code>存储器管理单元(Memory Management Unit, MMU)</code> 的部件来完成。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133530.jpeg" srcset="/img/loading.gif" alt="img"></p><p>缓存和 MMU 的出现是对系统的性能有很重要的影响，在多道程序系统中，从一个程序切换到另一个程序的机制称为 <code>上下文切换(context switch)</code>，对来自缓存中的资源进行修改并把其写回磁盘是很有必要的。</p><h3 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h3><p>CPU 和存储器不是操作系统需要管理的全部，<code>I/O</code> 设备也与操作系统关系密切。可以参考上面这个图片，I/O 设备一般包括两个部分：设备控制器和设备本身。控制器本身是一块芯片或者一组芯片，它能够控制物理设备。它能够接收操作系统的指令，例如，从设备中读取数据并完成数据的处理。</p><p>在许多情况下，实际控制设备的过程是非常复杂而且存在诸多细节。因此控制器的工作就是为操作系统提供一个更简单（但仍然非常复杂）的接口。也就是屏蔽物理细节。<strong>任何复杂的东西都可以加一层代理来解决，这是计算机或者人类社会很普世的一个解决方案</strong></p><p>I/O 设备另一部分是设备本身，设备本身有一个相对简单的接口，这是因为接口既不能做很多工作，而且也已经被标准化了。例如，标准化后任何一个 SATA 磁盘控制器就可以适配任意一种 SATA 磁盘，所以标准化是必要的。<code>ATA</code> 代表 <code>高级技术附件(AT Attachment)</code>，而 SATA 表示<code>串行高级技术附件(Serial ATA)</code>。</p><blockquote><p>“</p><p>AT 是啥？它是 IBM 公司的第二代个人计算机的<code>高级</code>技术成果，使用 1984 年推出的 6MHz 80286 处理器，这个处理器是当时最强大的。</p></blockquote><p>像是高级这种词汇应该慎用，否则 20 年后再回首很可能会被无情打脸。</p><p>现在 SATA 是很多计算机的标准硬盘接口。由于实际的设备接口隐藏在控制器中，所以操作系统看到的是对控制器的接口，这个接口和设备接口有很大区别。</p><p>每种类型的设备控制器都是不同的，所以需要不同的软件进行控制。专门与控制器进行信息交流，发出命令处理指令接收响应的软件，称为 <code>设备驱动程序(device driver)</code>。每个控制器厂家都应该针对不同的操作系统提供不同的设备驱动程序。</p><p>为了使设备驱动程序能够工作，必须把它安装在操作系统中，这样能够使它在内核态中运行。要将设备驱动程序装入操作系统，一般有三个途径</p><ul><li>第一个途径是将内核与设备启动程序重新连接，然后重启系统。这是 <code>UNIX</code> 系统采用的工作方式</li><li>第二个途径是在一个操作系统文件中设置一个入口，通知该文件需要一个设备驱动程序，然后重新启动系统。在重新系统时，操作系统回寻找有关的设备启动程序并把它装载，这是 <code>Windows</code> 采用的工作方式</li><li>第三个途径是操作系统能够在运行时接收新的设备驱动程序并立刻安装，无需重启操作系统，这种方式采用的少，但是正变得普及起来。热插拔设备，比如 USB 和 IEEE 1394 都需要动态可装载的设备驱动程序。</li></ul><p>每个设备控制器都有少量用于通信的寄存器，例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数的寄存器。要激活控制器，设备驱动程序回从操作系统获取一条指令，然后翻译成对应的值，并写入设备寄存器中，所有设备寄存器的结合构成了 <code>I/O 端口空间</code> 。</p><p>在一些计算机中，设备寄存器会被映射到操作系统的可用地址空间，使他们能够向内存一样完成读写操作。在这种计算机中，不需要专门的 I/O 指令，用户程序可以被硬件阻挡在外，防止其接触这些存储器地址（例如，采用基址寄存器和变址寄存器）。在另一些计算机中，设备寄存器被放入一个专门的 I/O 端口空间，每个寄存器都有一个端口地址。在这些计算机中，特殊的 <code>IN</code> 和 <code>OUT</code> 指令会在内核态下启用，它能够允许设备驱动程序和寄存器进行读写。前面第一种方式会限制特殊的 I/O 指令但是允许一些地址空间；后者不需要地址空间但是需要特殊的指令，这两种应用都很广泛。</p><p><strong>实现输入和输出的方式有三种</strong>。</p><ul><li>在最简单的方式中，用户程序会发起系统调用，内核会将其转换为相应驱动程序的程序调用，然后设备驱动程序启动 I/O 并循环检查该设备，看该设备是否完成了工作（一般会有一些二进制位用来指示设备仍在忙碌中）。当 I/O 调用完成后，设备驱动程序把数据送到指定的地方并返回。然后操作系统会将控制权交给调用者。这种方式称为 <code>忙等待(busy waiting)</code>，这种方式的缺点是要一直占据 CPU，CPU 会一直轮询 I/O 设备直到 I/O 操作完成。</li><li>第二种方式是设备驱动程序启动设备并且让该设备在操作完成时发生中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备操作完成时，它发出一个 <code>中断</code> 通知操作完成。</li></ul><p>在操作系统中，中断是非常重要的，所以这需要更加细致的讨论一下。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133101.png" srcset="/img/loading.gif" alt="img"></p><p>如上图所示，这是一个三步的 I/O 过程，第一步，设备驱动程序会通过写入设备寄存器告诉控制器应该做什么。然后，控制器启动设备。当控制器完成读取或写入被告知需要传输的字节后，它会在步骤 2 中使用某些总线向中断控制器发送信号。如果中断控制器准备好了接收中断信号（如果正忙于一个优先级较高的中断，则可能不会接收），那么它就会在 CPU 的一个引脚上面声明。这就是步骤3</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133523.jpeg" srcset="/img/loading.gif" alt="img"></p><p>在第四步中，中断控制器把该设备的编号放在总线上，这样 CPU 可以读取总线，并且知道哪个设备完成了操作（可能同时有多个设备同时运行）。</p><p>一旦 CPU 决定去实施中断后，程序计数器和 PSW 就会被压入到当前堆栈中并且 CPU 会切换到内核态。设备编号可以作为内存的一个引用，用来寻找该设备中断处理程序的地址。这部分内存称作<code>中断向量(interrupt vector)</code>。一旦中断处理程序（中断设备的设备驱动程序的一部分）开始后，它会移除栈中的程序计数器和 PSW 寄存器，并把它们进行保存，然后查询设备的状态。在中断处理程序全部完成后，它会返回到先前用户程序尚未执行的第一条指令，这个过程如下</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133516.png" srcset="/img/loading.gif" alt="img"></p><ul><li>实现 I/O 的第三种方式是使用特殊的硬件：<code>直接存储器访问(Direct Memory Access, DMA)</code> 芯片。它可以控制内存和某些控制器之间的位流，而无需 CPU 的干预。CPU 会对 DMA 芯片进行设置，说明需要传送的字节数，有关的设备和内存地址以及操作方向。当 DMA 芯片完成后，会造成中断，中断过程就像上面描述的那样。我们会在后面具体讨论中断过程</li></ul><p>当另一个中断处理程序正在运行时，中断可能（并且经常）发生在不合宜的时间。因此，CPU 可以禁用中断，并且可以在之后重启中断。在 CPU 关闭中断后，任何已经发出中断的设备，可以继续保持其中断信号处理，但是 CPU 不会中断，直至中断再次启用为止。如果在关闭中断时，已经有多个设备发出了中断信号，中断控制器将决定优先处理哪个中断，通常这取决于事先赋予每个设备的优先级，最高优先级的设备优先赢得中断权，其他设备则必须等待。</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>上面的结构（简单个人计算机的组件图）在小型计算机已经使用了多年，并用在早期的 IBM PC 中。然而，随着处理器核内存变得越来越快，单个总线处理所有请求的能力也达到了上线，其中也包括 IBM PC 总线。必须放弃使用这种模式。其结果导致了其他总线的出现，它们处理 I/O 设备以及 CPU 到存储器的速度都更快。这种演变的结果导致了下面这种结构的出现。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133511.jpeg" srcset="/img/loading.gif" alt="img"></p><p>上图中的 x86 系统包含很多总线，<strong>高速缓存、内存、PCIe、PCI、USB、SATA 和 DMI</strong>，每条总线都有不同的传输速率和功能。操作系统必须了解所有的总线配置和管理。其中最主要的总线是 <code>PCIe(Peripheral Component Interconnect Express)</code> 总线。</p><p>Intel 发明的 PCIe 总线也是作为之前古老的 PCI 总线的继承者，而古老的 PCI 总线也是为了取代古董级别的 <code>ISA(Industry Standard Architecture)</code> 总线而设立的。数十 Gb/s 的传输能力使得 PCIe 比它的前身快很多，而且它们本质上也十分不同。直到发明 PCIe 的 2004 年，大多数总线都是并行且共享的。<code>共享总线架构(shared bus architeture)</code> 表示多个设备使用一些相同的电线传输数据。因此，当多个设备同时发送数据时，此时你需要一个决策者来决定谁能够使用总线。而 PCIe 则不一样，它使用专门的端到端链路。传统 PCI 中使用的<code>并行总线架构(parallel bus architecture)</code> 表示通过多条电线发送相同的数据字。例如，在传统的 PCI 总线上，一个 32 位数据通过 32 条并行的电线发送。而 PCIe 则不同，它选用了<code>串行总线架构(serial bus architecture)</code> ，并通过单个连接（称为通道）发送消息中的所有比特数据，就像网络数据包一样。这样做会简化很多，因为不再确保所有 32 位数据在同一时刻准确到达相同的目的地。通过将多个数据通路并行起来，并行性仍可以有效利用。例如，可以使用 32 条数据通道并行传输 32 条消息。</p><p>在上图结构中，CPU 通过 DDR3 总线与内存对话，通过 PCIe 总线与外围图形设备 （GPU）对话，通过 <code>DMI(Direct Media Interface)</code>总线经集成中心与所有其他设备对话。而集成控制中心通过串行总线与 USB 设备对话，通过 SATA 总线与硬盘和 DVD 驱动器对话，通过 PCIe 传输以太网络帧。</p><p>不仅如此，每一个核</p><p><code>USB(Univversal Serial Bus)</code> 是用来将所有慢速 I/O 设备（比如键盘和鼠标）与计算机相连的设备。USB 1.0 可以处理总计 12 Mb/s 的负载，而 USB 2.0 将总线速度提高到 480Mb/s ，而 USB 3.0 能达到不小于 5Gb/s 的速率。所有的 USB 设备都可以直接连接到计算机并能够立刻开始工作，而不像之前那样要求重启计算机。</p><p><code>SCSI(Small Computer System Interface)</code> 总线是一种高速总线，用在高速硬盘，扫描仪和其他需要较大带宽的设备上。现在，它们主要用在服务器和工作站中，速度可以达到 640MB/s 。</p><h3 id="计算机启动过程"><a href="#计算机启动过程" class="headerlink" title="计算机启动过程"></a>计算机启动过程</h3><p>那么有了上面一些硬件再加上操作系统的支持，我们的计算机就可以开始工作了，那么计算机的启动过程是怎样的呢？下面只是一个简要版的启动过程</p><p>在每台计算机上有一块双亲板，也就是母板，母板也就是主板，它是计算机最基本也就是最重要的部件之一。主板一般为矩形电路板，上面安装了组成计算机的主要电路系统，一般有 BIOS 芯片、I/O 控制芯片、键盘和面板控制开关接口、指示灯插接件、扩充插槽、主板及插卡的直流电源供电接插件等元件。</p><p>在母板上有一个称为 <code>基本输入输出系统(Basic Input Output System, BIOS)</code>的程序。在 BIOS 内有底层 I/O 软件，包括读键盘、写屏幕、磁盘I/O 以及其他过程。如今，它被保存在闪存中，它是非易失性的，但是当BIOS 中发现错误时，可以由操作系统进行更新。</p><p>在计算机<code>启动(booted)</code>时，BIOS 开启，它会首先检查所安装的 RAM 的数量，键盘和其他基础设备是否已安装并且正常响应。接着，它开始扫描 PCIe 和 PCI 总线并找出连在上面的所有设备。即插即用的设备也会被记录下来。如果现有的设备和系统上一次启动时的设备不同，则新的设备将被重新配置。</p><p>蓝后，BIOS 通过尝试存储在 <code>CMOS</code> 存储器中的设备清单尝试启动设备</p><blockquote><p>“</p><p>CMOS是 <code>Complementary Metal Oxide Semiconductor（互补金属氧化物半导体）</code>的缩写。它是指制造大规模集成电路芯片用的一种技术或用这种技术制造出来的芯片，是电脑主板上的一块可读写的 <code>RAM</code> 芯片。因为可读写的特性，所以在电脑主板上用来保存 BIOS 设置完电脑硬件参数后的数据，这个芯片仅仅是用来存放数据的。</p><p>而对 BIOS 中各项参数的设定要通过专门的程序。BIOS 设置程序一般都被厂商整合在芯片中，在开机时通过特定的按键就可进入 BIOS 设置程序，方便地对系统进行设置。因此 BIOS 设置有时也被叫做 CMOS 设置。</p></blockquote><p>用户可以在系统启动后进入一个 BIOS 配置程序，对设备清单进行修改。然后，判断是否能够从外部 <code>CD-ROM</code> 和 USB 驱动程序启动，如果启动失败的话（也就是没有），系统将从硬盘启动，boots 设备中的第一个扇区被读入内存并执行。该扇区包含一个程序，该程序通常在引导扇区末尾检查分区表以确定哪个分区处于活动状态。然后从该分区读入第二个启动加载程序，该加载器从活动分区中读取操作系统并启动它。</p><p>然后操作系统会询问 BIOS 获取配置信息。对于每个设备来说，会检查是否有设备驱动程序。如果没有，则会向用户询问是否需要插入 <code>CD-ROM</code> 驱动（由设备制造商提供）或者从 Internet 上下载。一旦有了设备驱动程序，操作系统会把它们加载到内核中，然后初始化表，创建所需的后台进程，并启动登录程序或GUI。</p><h2 id="操作系统博物馆"><a href="#操作系统博物馆" class="headerlink" title="操作系统博物馆"></a>操作系统博物馆</h2><p>操作系统已经存在了大半个世纪，在这段时期内，出现了各种类型的操作系统，但并不是所有的操作系统都很出名，下面就罗列一些比较出名的操作系统</p><h3 id="大型机操作系统"><a href="#大型机操作系统" class="headerlink" title="大型机操作系统"></a>大型机操作系统</h3><p>高端一些的操作系统是大型机操作系统，这些大型操作系统可在大型公司的数据中心找到。这些计算机的 I/O 容量与个人计算机不同。一个大型计算机有 1000 个磁盘和数百万 G 字节的容量是很正常，如果有这样一台个人计算机朋友会很羡慕。大型机也在高端 Web 服务器、大型电子商务服务站点上。</p><h3 id="服务器操作系统"><a href="#服务器操作系统" class="headerlink" title="服务器操作系统"></a>服务器操作系统</h3><p>下一个层次是服务器操作系统。它们运行在服务器上，服务器可以是大型个人计算机、工作站甚至是大型机。它们通过网络为若干用户服务，并且允许用户共享硬件和软件资源。服务器可提供打印服务、文件服务或 Web 服务。Internet 服务商运行着许多台服务器机器，为用户提供支持，使 Web 站点保存 Web 页面并处理进来的请求。典型的服务器操作系统有 Solaris、FreeBSD、Linux 和 Windows Server 201x</p><h3 id="多处理器操作系统"><a href="#多处理器操作系统" class="headerlink" title="多处理器操作系统"></a>多处理器操作系统</h3><p>获得大型计算能力的一种越来越普遍的方式是将多个 CPU 连接到一个系统中。依据它们连接方式和共享方式的不同，这些系统称为并行计算机，多计算机或多处理器。他们需要专门的操作系统，不过通常采用的操作系统是配有通信、连接和一致性等专门功能的服务器操作系统的变体。</p><p>个人计算机中近来出现了多核芯片，所以常规的台式机和笔记本电脑操作系统也开始与小规模多处理器打交道，而核的数量正在与时俱进。许多主流操作系统比如 Windows 和 Linux 都可以运行在多核处理器上。</p><h3 id="个人计算机系统"><a href="#个人计算机系统" class="headerlink" title="个人计算机系统"></a>个人计算机系统</h3><p>接下来一类是个人计算机操作系统。现代个人计算机操作系统支持多道处理程序。在启动时，通常有几十个程序开始运行，它们的功能是为单个用户提供良好的支持。这类系统广泛用于字处理、电子表格、游戏和 Internet 访问。常见的例子是 Linux、FreeBSD、Windows 7、Windows 8 和苹果公司的 OS X 。</p><h3 id="掌上计算机操作系统"><a href="#掌上计算机操作系统" class="headerlink" title="掌上计算机操作系统"></a>掌上计算机操作系统</h3><p>随着硬件越来越小化，我们看到了平板电脑、智能手机和其他掌上计算机系统。掌上计算机或者 <code>PDA(Personal Digital Assistant)，个人数字助理</code> 是一种可以握在手中操作的小型计算机。这部分市场已经被谷歌的 <code>Android</code> 系统和苹果的 <code>IOS</code>主导。</p><h3 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h3><p>嵌入式操作系统用来控制设备的计算机中运行，这种设备不是一般意义上的计算机，并且不允许用户安装软件。典型的例子有微波炉、汽车、DVD 刻录机、移动电话以及 MP3 播放器一类的设备。所有的软件都运行在 ROM 中，这意味着应用程序之间不存在保护，从而获得某种简化。主要的嵌入式系统有 Linux、QNX 和 VxWorks</p><h3 id="传感器节点操作系统"><a href="#传感器节点操作系统" class="headerlink" title="传感器节点操作系统"></a>传感器节点操作系统</h3><p>有许多用途需要配置微小传感器节点网络。这些节点是一种可以彼此通信并且使用无线通信基站的微型计算机。这类传感器网络可以用于建筑物周边保护、国土边界保卫、森林火灾探测、气象预测用的温度和降水测量等。</p><p>每个传感器节点是一个配有 CPU、RAM、ROM 以及一个或多个环境传感器的实实在在的计算机。节点上运行一个小型但是真是的操作系统，通常这个操作系统是事件驱动的，可以响应外部事件。</p><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><p>另一类操作系统是实时操作系统，这些系统的特征是将时间作为关键参数。例如，在工业过程控制系统中，工厂中的实时计算机必须收集生产过程的数据并用有关数据控制机器。如果某个动作必须要在规定的时刻发生，这就是<code>硬实时系统</code>。可以在工业控制、民用航空、军事以及类似应用中看到很多这样的系统。另一类系统是 <code>软实时系统</code>，在这种系统中，虽然不希望偶尔违反最终时限，但仍可以接受，并不会引起任何永久性损害。数字音频或多媒体系统就是这类系统。智能手机也是软实时系统。</p><h3 id="智能卡操作系统"><a href="#智能卡操作系统" class="headerlink" title="智能卡操作系统"></a>智能卡操作系统</h3><p>最小的操作系统运行在智能卡上。智能卡是一种包含一块 CPU 芯片的信用卡。它有非常严格的运行能耗和存储空间的限制。有些卡具有单项功能，如电子支付；有些智能卡是面向 Java 的。这意味着在智能卡的 ROM 中有一个 Java 虚拟机（Java Virtual Machine, JVM）解释器。</p><h2 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h2><p>大部分操作系统提供了特定的基础概念和抽象，例如进程、地址空间、文件等，它们是需要理解的核心内容。下面我们会简要介绍一些基本概念，为了说明这些概念，我们会不时的从 <code>UNIX</code> 中提出示例，相同的示例也会存在于其他系统中，我们后面会进行介绍。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>操作系统一个很关键的概念就是 <code>进程(Process)</code>。进程的本质就是操作系统执行的一个程序。与每个进程相关的是<code>地址空间(address space)</code>，这是从某个最小值的存储位置(通常是零)到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写操作。地址空间中存放有可执行程序，程序所需要的数据和它的栈。与每个进程相关的还有资源集，通常包括<code>寄存器(registers)</code>（寄存器一般包括<code>程序计数器(program counter)</code>和<code>堆栈指针(stack pointer)</code>）、打开文件的清单、突发的报警、有关的进程清单和其他需要执行程序的信息。你可以把进程看作是容纳运行一个程序所有信息的一个容器。</p><p>对进程建立一种直观感觉的方式是考虑建立一种多程序的系统。考虑下面这种情况：用户启动一个视频编辑程序，指示它按照某种格式转换视频，然后再去浏览网页。同时，一个检查电子邮件的后台进程被唤醒并开始运行，这样，我们目前就会有三个活动进程：视频编辑器、Web 浏览器和电子邮件接收程序。操作系统周期性的挂起一个进程然后启动运行另一个进程，这可能是由于过去一两秒钟程序用完了 CPU 分配的时间片，而 CPU 转而运行另外的程序。</p><p>像这样暂时中断进程后，下次应用程序在此启动时，必须要恢复到与中断时刻相同的状态，这在我们用户看起来是习以为常的事情，但是操作系统内部却做了巨大的事情。<strong>这就像和足球比赛一样，一场完美精彩的比赛是可以忽略裁判的存在的</strong>。这也意味着在挂起时该进程的所有信息都要被保存下来。例如，进程可能打开了多个文件进行读取。与每个文件相关联的是提供当前位置的指针（即下一个需要读取的字节或记录的编号）。当进程被挂起时，必须要保存这些指针，以便在重新启动进程后执行的 <code>read</code>调用将能够正确的读取数据。在许多操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均存放在操作系统的一张表中，称为 <code>进程表(process table)</code>，进程表是数组或者链表结构，当前存在每个进程都要占据其中的一项。</p><p>所以，一个挂起的进程包括：进程的地址空间（往往称作<code>磁芯映像</code>， core image，纪念过去的磁芯存储器），以及对应的进程表项（其中包括寄存器以及稍后启动该进程所需要的许多其他信息）。</p><p>与进程管理有关的最关键的系统调用往往是决定着进程的创建和终止的系统调用。考虑一个典型的例子，有一个称为 <code>命令解释器(command interpreter)</code> 或 <code>shell</code> 的进程从终端上读取命令。此时，用户刚键入一条命令要求编译一个程序。shell 必须先创建一个新进程来执行编译程序，当编译程序结束时，它执行一个系统调用来终止自己的进程。</p><p>如果一个进程能够创建一个或多个进程（称为<code>子进程</code>），而且这些进程又可以创建子进程，则很容易找到进程数，如下所示</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133502.png" srcset="/img/loading.gif" alt="img"></p><p>上图表示一个进程树的示意图，进程 A 创建了两个子进程 B 和进程 C，子进程 B 又创建了三个子进程 D、E、F。</p><p>合作完成某些作业的相关进程经常需要彼此通信来完成作业，这种通信称为<code>进程间通信(interprocess communication)</code>。我们在后面会探讨进程间通信。</p><p>其他可用的进程系统调用包括：申请更多的内存（或释放不再需要的内存），等待一个子进程结束，用另一个程序覆盖该程序。</p><p>有时，需要向一个正在运行的进程传递信息，而该进程并没有等待接收信息。例如，一个进程通过网络向另一台机器上的进程发送消息进行通信。为了保证一条消息或消息的应答不丢失。发送者要求它所在的操作系统在指定的若干秒后发送一个通知，这样如果对方尚未收到确认消息就可以进行重新发送。在设定该定时器后，程序可以继续做其他工作。</p><p>在限定的时间到达后，操作系统会向进程发送一个 <code>警告信号(alarm signal)</code>。这个信号引起该进程暂时挂起，无论该进程正在做什么，系统将其寄存器的值保存到堆栈中，并开始重新启动一个特殊的信号处理程，比如重新发送可能丢失的消息。这些信号是软件模拟的硬件中断，除了定时器到期之外，该信号可以通过各种原因产生。许多由硬件检测出来的陷阱，如执行了非法指令或使用了无效地址等，也被转换成该信号并交给这个进程。</p><p>系统管理器授权每个进程使用一个给定的 <code>UID(User IDentification)</code>。每个启动的进程都会有一个操作系统赋予的 UID，子进程拥有与父进程一样的 UID。用户可以是某个组的成员，每个组也有一个 <code>GID(Group IDentification)</code>。</p><p>在 UNIX 操作系统中，有一个 UID 是 <code>超级用户(superuser)</code>，或者 Windows 中的<code>管理员(administrator)</code>，它具有特殊的权利，可以违背一些保护规则。在大型系统中，只有系统管理员掌握着那些用户可以称为超级用户。</p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>每台计算机都有一些主存用来保存正在执行的程序。在一个非常简单的操作系统中，仅仅有一个应用程序运行在内存中。为了运行第二个应用程序，需要把第一个应用程序移除才能把第二个程序装入内存。</p><p>复杂一些的操作系统会允许多个应用程序同时装入内存中运行。为了防止应用程序之间相互干扰（包括操作系统），需要有某种保护机制。虽然此机制是在硬件中实现，但却是由操作系统控制的。</p><p>上述观点涉及对计算机主存的管理和保护。另一种同等重要并与存储器有关的内容是管理进程的地址空间。通常，每个进程有一些可以使用的地址集合，典型值从 0 开始直到某个最大值。一个进程可拥有的最大地址空间小于主存。在这种情况下，即使进程用完其地址空间，内存也会有足够的内存运行该进程。</p><p>但是，在许多 32 位或 64 位地址的计算机中，分别有 2^32 或 2^64 字节的地址空间。如果一个进程有比计算机拥有的主存还大的地址空间，而且该进程希望使用全部的内存，那该怎么处理？在早期的计算机中是无法处理的。但是现在有了一种<code>虚拟内存</code>的技术，正如前面讲到过的，操作系统可以把部分地址空间装入主存，部分留在磁盘上，并且在需要时来回交换它们。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>几乎所有操作系统都支持的另一个关键概念就是文件系统。如前所述，操作系统的一项主要功能是屏蔽磁盘和其他 I/O 设备的细节特性，给程序员提供一个良好、清晰的独立于设备的抽象文件模型。<strong>创建文件、删除文件、读文件和写文件</strong> 都需要系统调用。在文件可以读取之前，必须先在磁盘上定位和打开文件，在文件读过之后应该关闭该文件，有关的系统调用则用于完成这类操作。</p><p>为了提供保存文件的地方，大多数个人计算机操作系统都有<code>目录(directory)</code> 的概念，从而可以把文件分组。比如，学生可以给每个课程都创建一个目录，用于保存该学科的资源，另一个目录可以存放电子邮件，再有一个目录可以存放万维网主页。这就需要系统调用创建和删除目录、将已有文件放入目录中，从目录中删除文件等。目录项可以是文件或者目录，目录和目录之间也可以嵌套，这样就产生了文件系统</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133145.jpeg" srcset="/img/loading.gif" alt="img"></p><p>进程和文件层次都是以树状的结构组织，但这两种树状结构有不少不同之处。一般进程的树状结构层次不深（很少超过三层），而文件系统的树状结构要深一些，通常会到四层甚至五层。进程树层次结构是暂时的，通常最多存在几分钟，而目录层次则可能存在很长时间。进程和文件在权限保护方面也是有区别的。一般来说，父进程能控制和访问子进程，而在文件和目录中通常存在一种机制，使文件所有者之外的其他用户也能访问该文件。</p><p>目录层结构中的每一个文件都可以通过从目录的顶部即 <code>根目录(Root directory)</code> 开始的<code>路径名(path name)</code> 来确定。绝对路径名包含了从根目录到该文件的所有目录清单，它们之间用斜杠分隔符分开，在上面的大学院系文件系统中，文件 CS101 的路径名是 <code>/Faculty/Prof.Brown/Courses/CS101</code>。最开始的斜杠分隔符代表的是<code>根目录 /</code>，也就是文件系统的绝对路径。</p><blockquote><p>“</p><p>出于历史原因，Windows 下面的文件系统以 <code>\</code> 来作为分隔符，但是 Linux 会以 <code>/</code> 作为分隔符。</p></blockquote><p>在上面的系统中，每个进程会有一个 <code>工作目录(working directory)</code>，对于没有以斜线开头给出绝对地址的路径，将在这个工作目录下寻找。如果 <code>/Faculty/Prof.Brown</code> 是工作目录，那么 <code>/Courses/CS101</code> 与上面给定的绝对路径名表示的是同一个文件。进程可以通过使用系统调用指定新的工作目录，从而变更其工作目录。</p><p>在读写文件之前，首先需要打开文件，检查其访问权限。若权限许可，系统将返回一个小整数，称作<code>文件描述符(file descriptor)</code>，供后续操作使用。若禁止访问，系统则返回一个错误码。</p><p>在 UNIX 中，另一个重要的概念是 <code>特殊文件(special file)</code>。提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像使用系统调用读写文件一样，I/O 设备也可以通过同样的系统调用进行读写。特殊文件有两种，一种是<code>块儿特殊文件(block special file)</code> 和 <code>字符特殊文件(character special file)</code>。块特殊文件指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读取第4块，程序可以直接访问设备的第4块而不必考虑存放在该文件的文件系统结构。类似的，字符特殊文件用于打印机、调制解调起和其他接受或输出字符流的设备。按照惯例，特殊文件保存在 <code>/dev</code> 目录中。例如，/devv/lp 是打印机。</p><p>还有一种与进程和文件相关的特性是管道，<code>管道(pipe)</code> 是一种虚文件，他可以连接两个进程</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133202.png" srcset="/img/loading.gif" alt="img"></p><p>如果 A 和 B 希望通过管道对话，他们必须提前设置管道。当进程 A 相对进程 B 发送数据时，它把数据写到管道上，相当于管道就是输出文件。这样，在 UNIX 中两个进程之间的通信就非常类似于普通文件的读写了。</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>计算机中含有大量的信息，用户希望能够对这些信息中有用而且重要的信息加以保护，这些信息包括电子邮件、商业计划等，管理这些信息的安全性完全依靠操作系统来保证。例如，文件提供授权用户访问。</p><p>比如 UNIX 操作系统，UNIX 操作系统通过对每个文件赋予一个 9 位二进制保护代码，对 UNIX 中的文件实现保护。该保护代码有三个位子段，一个用于所有者，一个用于与所有者同组（用户被系统管理员划分成组）的其他成员，一个用于其他人。每个字段中有一位用于读访问，一位用于写访问，一位用于执行访问。这些位就是著名的 <code>rwx位</code>。例如，保护代码 <code>rwxr-x--x</code> 的含义是所有者可以读、写或执行该文件，其他的组成员可以读或执行（但不能写）此文件、而其他人可以执行（但不能读和写）该文件。</p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>操作系统是执行系统调用的代码。编辑器、编译器、汇编程序、链接程序、使用程序以及命令解释符等，尽管非常重要，非常有用，但是它们确实不是操作系统的组成部分。下面我们着重介绍一下 UNIX 下的命令提示符，也就是 <code>shell</code>，shell 虽然有用，但它也不是操作系统的一部分，然而它却能很好的说明操作系统很多特性，下面我们就来探讨一下。</p><p>shell 有许多种，例如 <strong>sh、csh、ksh 以及 bash</strong>等，它们都支持下面这些功能，最早起的 shell 可以追溯到 sh</p><p>用户登录时，会同时启动一个 shell，它以终端作为标准输入和标准输出。首先显示<code>提示符(prompt)</code>，它可能是一个<code>美元符号($)</code>，提示用户 shell 正在等待接收命令，假如用户输入</p><div class="hljs"><pre><code class="hljs applescript"><span class="hljs-built_in">date</span></code></pre></div><p>shell 会创建一个子进程，并运行 date 做为子进程。在该子进程运行期间，shell 将等待它结束。在子进程完成时，shell 会显示提示符并等待下一行输入。</p><p>用户可以将标准输出重定向到一个文件中，例如</p><div class="hljs"><pre><code class="hljs applescript"><span class="hljs-built_in">date</span> &gt; <span class="hljs-built_in">file</span></code></pre></div><p>同样的，也可以将标准输入作为重定向</p><div class="hljs"><pre><code class="hljs vim"><span class="hljs-keyword">sort</span> <span class="hljs-symbol">&lt;file1&gt;</span> file2</code></pre></div><p>这会调用 sort 程序来接收 file1 的内容并把结果输出到 file2。</p><p>可以将一个应用程序的输出通过管道作为另一个程序的输入，因此有</p><div class="hljs"><pre><code class="hljs vim"><span class="hljs-keyword">cat</span> file1 file2 file3 | <span class="hljs-keyword">sort</span> &gt; /dev/<span class="hljs-keyword">lp</span></code></pre></div><p>这会调用 cat 应用程序来合并三个文件，将其结果输送到 sort 程序中并按照字典进行排序。sort 应用程序又被重定向到 /dev/lp ，显然这是一个打印操作。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>我们已经可以看到操作系统提供了两种功能：为用户提供应用程序抽象和管理计算机资源。对于大部分在应用程序和操作系统之间的交互主要是应用程序的抽象，例如创建、写入、读取和删除文件。计算机的资源管理对用户来说基本上是透明的。因此，用户程序和操作系统之间的接口主要是处理抽象。为了真正理解操作系统的行为，我们必须仔细的分析这个接口。</p><p>多数现代操作系统都有功能相同但是细节不同的系统调用，引发操作系统的调用依赖于计算机自身的机制，而且必须用汇编代码表达。<strong>任何单 CPU 计算机一次执行执行一条指令</strong>。如果一个进程在用户态下运行用户程序，例如从文件中读取数据。那么如果想要把控制权交给操作系统控制，那么必须执行一个异常指令或者系统调用指令。操作系统紧接着需要参数检查找出所需要的调用进程。操作系统紧接着进行参数检查找出所需要的调用进程。然后执行系统调用，把控制权移交给系统调用下面的指令。大致来说，系统调用就像是执行了一个特殊的过程调用，但是只有<strong>系统调用能够进入内核态而过程调用则不能进入内核态</strong>。</p><p>为了能够了解具体的调用过程，下面我们以 <code>read</code> 方法为例来看一下调用过程。像上面提到的那样，会有三个参数，第一个参数是指定文件、第二个是指向缓冲区、第三个参数是给定需要读取的字节数。就像几乎所有系统调用一样，它通过使用与系统调用相同的名称来调用一个函数库，从而从C程序中调用：read。</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">count</span> = read(fd,buffer,nbytes)<span class="hljs-comment">;</span></code></pre></div><p>系统调用在 count 中返回实际读出的字节数。这个值通常与 nbytes 相同，但也可能更小。比如在读过程中遇到了文件尾的情况。</p><p>如果系统调用不能执行，不管是因为无效的参数还是磁盘错误，count 的值都会被置成 -1，然后在全局变量 <code>errno</code> 中放入错误信号。程序应该进场检查系统调用的结果以了解是否出错。</p><p>系统调用是通过一系列的步骤实现的，为了更清楚的说明这个概念，我们还以 read 调用为例，在准备系统调用前，首先会把参数压入堆栈，如下所示</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133223.jpeg" srcset="/img/loading.gif" alt="img"></p><p>C 和 C++ 编译器使用逆序（必须把第一个参数赋值给 printf(格式字符串)，放在堆栈的顶部）。第一个参数和第三个参数都是值调用，但是第二个参数通过引用传递，即传递的是缓冲区的地址（由 &amp; 指示），而不是缓冲的内容。然后是 C 调用系统库的 read 函数，这也是第四步。</p><p>在由汇编语言写成的库过程中，一般把系统调用的编号放在操作系统所期望的地方，如寄存器（第五步）。然后执行一个 <code>TRAP</code> 指令，将用户态切换到内核态，并在内核中的一个固定地址开始执行第六步。TRAP 指令实际上与过程调用指令非常相似，它们后面都跟随一个来自远处位置的指令，以及供以后使用的一个保存在栈中的返回地址。</p><p>TRAP 指令与过程调用指令存在两个方面的不同</p><ul><li>TRAP 指令会改变操作系统的状态，由用户态切换到内核态，而过程调用不改变模式</li><li>其次，TRAP 指令不能跳转到任意地址上。根据机器的体系结构，要么跳转到一个单固定地址上，或者指令中有一 8 位长的字段，它给定了内存中一张表格的索引，这张表格中含有跳转地址，然后跳转到指定地址上。</li></ul><p>跟随在 TRAP 指令后的内核代码开始检查系统调用编号，然后<code>dispatch</code>给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的、指向系统调用处理器的指针表来完成第七步。此时，系统调用处理器运行第八步，一旦系统调用处理器完成工作，控制权会根据 TRAP 指令后面的指令中返回给函数调用库第九步。这个过程接着以通常的过程调用返回的方式，返回到客户应用程序，这是第十步。然后调用完成后，操作系统还必须清除用户堆栈，然后增加<code>堆栈指针(increment stackpointer)</code>，用来清除调用 read 之前压入的参数。从而完成整个 read 调用过程。</p><p>在上面的第九步中我们说道，控制可能返回 TRAP 指令后面的指令，把控制权再移交给调用者这个过程中，系统调用会发生阻塞，从而避免应用程序继续执行。这么做是有原因的。例如，如果试图读键盘，此时并没有任何输入，那么调用者就必须被阻塞。在这种情形下，操作系统会检查是否有其他可以运行的进程。这样，当有用户输入 时候，进程会提醒操作系统，然后返回第 9 步继续运行。</p><p>下面，我们会列出一些常用的 <code>POSIX</code> 系统调用，POSIX 系统调用大概有 100 多个，它们之中最重要的一些调用见下表</p><p><strong>进程管理</strong></p><table><thead><tr><th align="left">调用</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">pid = fork()</td><td align="left">创建与父进程相同的子进程</td></tr><tr><td align="left">pid = waitpid(pid, &amp;statloc,options)</td><td align="left">等待一个子进程终止</td></tr><tr><td align="left">s = execve(name,argv,environp)</td><td align="left">替换一个进程的核心映像</td></tr><tr><td align="left">exit(status)</td><td align="left">终止进程执行并返回状态</td></tr></tbody></table><p><strong>文件管理</strong></p><table><thead><tr><th align="left">调用</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">fd = open(file, how,…)</td><td align="left">打开一个文件使用读、写</td></tr><tr><td align="left">s = close(fd)</td><td align="left">关闭一个打开的文件</td></tr><tr><td align="left">n = read(fd,buffer,nbytes)</td><td align="left">把数据从一个文件读到缓冲区中</td></tr><tr><td align="left">n = write(fd,buffer,nbytes)</td><td align="left">把数据从缓冲区写到一个文件中</td></tr><tr><td align="left">position = iseek(fd,offset,whence)</td><td align="left">移动文件指针</td></tr><tr><td align="left">s = stat(name,&amp;buf)</td><td align="left">取得文件状态信息</td></tr></tbody></table><p><strong>目录和文件系统管理</strong></p><table><thead><tr><th align="left">调用</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">s = mkdir(nname,mode)</td><td align="left">创建一个新目录</td></tr><tr><td align="left">s = rmdir(name)</td><td align="left">删去一个空目录</td></tr><tr><td align="left">s = link(name1,name2)</td><td align="left">创建一个新目录项 name2,并指向 name1</td></tr><tr><td align="left">s = unlink(name)</td><td align="left">删去一个目录项</td></tr><tr><td align="left">s = mount(special,name,flag)</td><td align="left">安装一个文件系统</td></tr><tr><td align="left">s = umount(special)</td><td align="left">卸载一个文件系统</td></tr></tbody></table><p><strong>其他</strong></p><table><thead><tr><th align="left">调用</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">s = chdir(dirname)</td><td align="left">改变工作目录</td></tr><tr><td align="left">s = chmod(name,mode)</td><td align="left">修改一个文件的保护位</td></tr><tr><td align="left">s = kill(pid, signal)</td><td align="left">发送信号给进程</td></tr><tr><td align="left">seconds = time(&amp;seconds)</td><td align="left">获取从 1970 年1月1日至今的时间</td></tr></tbody></table><p>上面的系统调用参数中有一些公共部分，例如 pid 系统进程 id，fd 是文件描述符，n 是字节数，position 是在文件中的偏移量、seconds 是流逝时间。</p><p>从宏观角度上看，这些系统调所提供的服务确定了多数操作系统应该具有的功能，下面分别来对不同的系统调用进行解释</p><h3 id="用于进程管理的系统调用"><a href="#用于进程管理的系统调用" class="headerlink" title="用于进程管理的系统调用"></a>用于进程管理的系统调用</h3><p>在 UNIX 中，<code>fork</code> 是唯一可以在 POSIX 中创建进程的途径，它创建一个原有进程的副本，包括所有的文件描述符、寄存器等内容。在 fork 之后，原有进程以及副本（父与子）就分开了。在 fork 过程中，所有的变量都有相同的值，虽然父进程的数据通过复制给子进程，但是后续对其中任何一个进程的修改不会影响到另外一个。fork 调用会返回一个值，在子进程中该值为 0 ，并且在父进程中等于子进程的 <code>进程标识符(Process IDentified,PID)</code>。使用返回的 PID，就可以看出来哪个是父进程和子进程。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133445.jpeg" srcset="/img/loading.gif" alt="img"></p><p>在多数情况下， 在 fork 之后，子进程需要执行和父进程不一样的代码。从终端读取命令，创建一个子进程，等待子进程执行命令，当子进程结束后再读取下一个输入的指令。为了等待子进程完成，父进程需要执行 <code>waitpid</code> 系统调用，父进程会等待直至子进程终止（若有多个子进程的话，则直至任何一个子进程终止）。waitpid 可以等待一个特定的子进程，或者通过将第一个参数设为 -1 的方式，等待任何一个比较老的子进程。当 waitpid 完成后，会将第二个参数 <code>statloc</code> 所指向的地址设置为子进程的退出状态（正常或异常终止以及退出值）。有各种可使用的选项，它们由第三个参数确定。例如，如果没有已经退出的子进程则立刻返回。</p><p>那么 shell 该如何使用 fork 呢？在键入一条命令后，shell 会调用 fork 命令创建一个新的进程。这个子进程会执行用户的指令。通过使用 <code>execve</code> 系统调用可以实现系统执行，这个系统调用会引起整个核心映像被一个文件所替代，该文件由第一个参数给定。下面是一个简化版的例子说明 fork、waitpid 和 execve 的使用</p><div class="hljs"><pre><code class="hljs angelscript">#define TRUE <span class="hljs-number">1</span><span class="hljs-comment">/* 一直循环下去 */</span><span class="hljs-keyword">while</span>(TRUE)&#123;<span class="hljs-comment">/* 在屏幕上显示提示符 */</span>type_prompt();    <span class="hljs-comment">/* 从终端读取输入 */</span>read_command(command,parameters)    <span class="hljs-comment">/* fork 子进程 */</span><span class="hljs-keyword">if</span>(fork() != <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">/* 父代码 */</span><span class="hljs-comment">/* 等待子进程执行完毕 */</span>waitpid(<span class="hljs-number">-1</span>, &amp;status, <span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 执行命令 */</span><span class="hljs-comment">/* 子代码 */</span>execve(command,parameters,<span class="hljs-number">0</span>)&#125;&#125;</code></pre></div><p>一般情况下，execve 有三个参数：将要执行的文件名称，一个指向变量数组的指针，以及一个指向环境数组的指针。这里对这些参数做一个简要的说明。</p><p>先看一个 shell 指令</p><div class="hljs"><pre><code class="hljs avrasm"><span class="hljs-keyword">cp</span> file1 file2</code></pre></div><p>此命令把 file1 复制到 file2 文件中，在 shell 执行 fork 之后，子进程定位并执行文件拷贝，并将源文件和目标文件的名称传递给它。</p><p>cp 的主程序（以及包含其他大多数 C 程序的主程序）包含声明</p><div class="hljs"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">main</span><span class="hljs-params">(argc,argv,envp)</span></span></code></pre></div><p>其中 argc 是命令行中参数数目的计数，包括程序名称。对于上面的例子，<code>argc</code> 是3。第二个参数<code>argv</code> 是数组的指针。该数组的元素 i 是指向该命令行第 i 个字符串的指针。在上面的例子中，argv[0] 指向字符串 cp，argv[1] 指向字符串 file1，argv[2] 指向字符串 file2。main 的第三个参数是指向环境的指针，该环境是一个数组，含有 <code>name = value</code> 的赋值形式，用以将诸如终端类型以及根目录等信息传送给程序。这些变量通常用来确定用户希望如何完成特定的任务（例如，使用默认打印机）。在上面的例子中，没有环境参数传递给 execve ，所以环境变量是 0 ，所以 execve 的第三个参数为 0 。</p><p>可能你觉得 execve 过于复杂，这时候我要鼓励一下你，execve 可能是 POSIX 的全部系统调用中最复杂的一个了，其他都比较简单。作为一个简单的例子，我们再来看一下 <code>exit</code> ，这是进程在执行完成后应执行的系统调用。这个系统调用有一个参数，它的退出状态是 0 - 255 之间，它通过 waitpid 系统调用中的 statloc 返回给父级。</p><p>UNIX 中的进程将内存划分成三个部分：<code>text segment,文本区</code>，例如程序代码，<code>data segment，数据区</code>，例如变量，<code>stack segment</code>，栈区域。数据向上增长而堆栈向下增长，如下图所示</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133437.png" srcset="/img/loading.gif" alt="img"></p><p>上图能说明三个部分的内存分配情况，夹在中间的是空闲区，也就是未分配的区域，堆栈在需要时自动的挤压空闲区域，不过数据段的扩展是显示地通过系统调用 <code>brk</code> 进行的，在数据段扩充后，该系统调用指向一个新地址。但是，这个调用不是 POSIX 标准中定义的，对于存储器的动态分配，鼓励程序员使用 <code>malloc</code> 函数，而 malloc 的内部实现则不是一个适合标准化的主题，因为几乎没有程序员直接使用它。</p><h3 id="用于文件管理的系统调用"><a href="#用于文件管理的系统调用" class="headerlink" title="用于文件管理的系统调用"></a>用于文件管理的系统调用</h3><p>许多系统调用都与文件系统有关，要读写一个文件，必须先将其打开。这个系统调用通过绝对路径名或指向工作目录的相对路径名指定要打开文件的名称，而代码 <code>O_RDONLY</code>、 <code>O_WRONLY</code> 或 <code>O_RDWR</code> 的含义分别是只读、只写或者两者都可以，为了创建一个新文件，使用 <code>O_CREATE</code> 参数。然后可使用返回的文件描述符进行读写操作。接着，可以使用 close 关闭文件，这个调用使得文件描述符在后续的 open 中被再次使用。</p><p>最常用的调用还是 <code>read</code> 和 <code>write</code>，我们再前面探讨过 read 调用，write 具有与 read 相同的参数。</p><p>尽管多数程序频繁的读写文件，但是仍有一些应用程序需要能够随机访问一个文件的任意部分。与每个文件相关的是一个指向文件当前位置的指针。在顺序读写时，该指针通常指向要读出（写入）的下一个字节。<code>Iseek</code> 调用可以改变该位置指针的值，这样后续的 read 或 write 调用就可以在文件的任何地方开始。</p><p>Iseek 有三个参数，<code>position = iseek(fd,offset,whence)</code>，第一个是文件描述符，第二个是文件位置，第三个是说明该文件位置是相对于文件起始位置，当前位置还是文件的结尾。在修改了指针之后，Iseek 所返回的值是文件中的绝对位置。</p><p>UNIX 为每个文件保存了该文件的类型（普通文件、特殊文件、目录等）、大小，最后修改时间以及其他信息，程序可以通过 <code>stat</code> 系统调用查看这些信息。<code>s = stat(name,&amp;buf)</code>，第一个参数指定了被检查的文件；第二个参数是一个指针，该指针指向存放这些信息的结构。对于一个打开的文件而言，fstat 调用完成同样的工作。</p><h3 id="用于目录管理的系统调用"><a href="#用于目录管理的系统调用" class="headerlink" title="用于目录管理的系统调用"></a>用于目录管理的系统调用</h3><p>下面我们探讨目录和整个文件系统的系统调用，上面探讨的是和某个文件有关的系统调用。<code>mkdir</code> 和 <code>rmdir</code> 分别用于创建<code>s = mkdir(nname,mode)</code> 和删除 <code>s = rmdir(name)</code> 空目录，下一个调用是 <code>s = link(name1,name2)</code> 它的作用是允许同一个文件以两个或者多个名称出现，多数情况下是在不同的目录中使用 link ，下面我们探讨一下 link 是如何工作的</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133431.png" srcset="/img/loading.gif" alt="img"></p><p>图中有两个用户 <code>ast</code> 和 <code>jim</code>，每个用户都有他自己的一个目录和一些文件，如果 ast 要执行一个包含下面系统调用的应用程序</p><div class="hljs"><pre><code class="hljs lasso"><span class="hljs-keyword">link</span>(<span class="hljs-string">"/usr/jim/memo"</span>, <span class="hljs-string">"/usr/ast/note"</span>);</code></pre></div><p>jim 中的 memo 文件现在会进入到 ast 的目录中，在 note 名称下。此后，<code>/usr/jim/memo</code>和 <code>/usr/ast/note</code> 会有相同的名称。</p><blockquote><p>“</p><p>用户目录是保存在 /usr，/user，/home 还是其他位置，都是由本地系统管理员决定的。</p></blockquote><p>要理解 link 是如何工作的需要清楚 link 做了什么操作。UNIX 中的每个文件都有一个独一无二的版本，也称作 <code>i - number，i-编号</code>，它标示着不同文件的版本。这个 i - 编号是 <code>i-nodes,i-节点</code>表的索引。每个文件都会表明谁拥有这个文件，这个磁盘块的位置在哪，等等。目录只是一个包含一组（i编号，ASCII名称）对应的文件。UNIX 中的第一个版本中，每个目录项都会有 16 个字节，2 个字节对应 i - 编号和 14 个字节对应其名称。现在需要一个更复杂的结构需要支持长文件名，但是从概念上讲一个目录仍是一系列（i-编号，ASCII 名称）的集合。在上图中，<code>mail</code> 的 i-编号为 16，依此类推。link 只是利用某个已有文件的 i-编号，创建一个新目录项（也许用一个新名称）。在上图 b 中，你会发现有两个相同的 70 i-编号的文件，因此它们需要有相同的文件。如果其中一个使用了 <code>unlink</code> 系统调用的话，其中一个会被移除，另一个将保留。如果两个文件都移除了，则 UNIX 会发现该文件不存在任何没有目录项（i-节点中的一个域记录着指向该文件的目录项），就会把该文件从磁盘中移除。</p><p>就像我们上面提到过的那样，<code>mount</code> 系统 <code>s = mount(special,name,flag)</code> 调用会将两个文件系统合并为一个。通常的情况是将根文件系统分布在硬盘（子）分区上，并将用户文件分布在另一个（子）分区上，该根文件系统包含常用命令的二进制（可执行）版本和其他使用频繁的文件。然后，用户就会插入可读取的 USB 硬盘。</p><p>通过执行 mount 系统调用，USB 文件系统可以被添加到根文件系统中，</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133425.jpeg" srcset="/img/loading.gif" alt="img"></p><p>如果用 C 语言来执行那就是</p><div class="hljs"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">mount</span><span class="hljs-params">(<span class="hljs-string">"/dev/sdb0"</span>,<span class="hljs-string">"/mnt"</span>,<span class="hljs-number">0</span>)</span></span></code></pre></div><p>这里，第一个参数是 USB 驱动器 0 的块特殊文件名称，第二个参数是被安装在树中的位置，第三个参数说明将要安装的文件系统是可读写的还是只读的。</p><p>当不再需要一个文件系统时，可以使用 umount 移除之。</p><h3 id="其他系统调用"><a href="#其他系统调用" class="headerlink" title="其他系统调用"></a>其他系统调用</h3><p>除了进程、文件、目录系统调用，也存在其他系统调用的情况，下面我们来探讨一下。我们可以看到上面其他系统调用只有四种，首先来看第一个 chdir，chdir 调用更改当前工作目录，在调用</p><div class="hljs"><pre><code class="hljs abnf">chdir(<span class="hljs-string">"/usr/ast/test"</span>)<span class="hljs-comment">;</span></code></pre></div><p>后，打开 xyz 文件，会打开 <code>/usr/ast/test/xyz</code> 文件，工作目录的概念消除了总是需要输入长文件名的需要。</p><p>在 UNIX 系统中，每个文件都会有保护模式，这个模式会有一个<code>读-写-执行</code>位，它用来区分所有者、组和其他成员。<code>chmod</code> 系统调用提供改变文件模式的操作。例如，要使一个文件除了对所有者之外的用户可读，你可以执行</p><div class="hljs"><pre><code class="hljs less"><span class="hljs-selector-tag">chmod</span>(<span class="hljs-string">"file"</span>,<span class="hljs-number">0644</span>);</code></pre></div><p><code>kill</code> 系统调用是用户和用户进程发送信号的方式，如果一个进程准备好捕捉一个特定的信号，那么在信号捕捉之前，会运行一个信号处理程序。如果进程没有准备好捕捉特定的信号，那么信号的到来会杀掉该进程（此名字的由来）。</p><p>POSIX 定义了若干时间处理的进程。例如，<code>time</code> 以秒为单位返回当前时间，0 对应着 1970 年 1月 1日。在一台 32 位字的计算机中，time 的最大值是 (2^32) - 1秒，这个数字对应 136 年多一点。所以在 2106 年，32 位的 UNIX 系统会发飙。如果读者现在有 32 位 UNIX 系统，建议在 2106 年更换位 64 位操作系统（偷笑～）。</p><h3 id="Win-32-API"><a href="#Win-32-API" class="headerlink" title="Win 32 API"></a>Win 32 API</h3><p>上面我们提到的都是 UNIX 系统调用，现在我们来聊聊 Win 32 中的系统调用。Windows 和 UNIX 在各自的编程方式上有着根本的不同。UNIX 程序由执行某些操作或执行其他操作的代码组成，进行系统调用以执行某些服务。Windows 系统则不同，Windows 应用程序通常是由事件驱动的。主程序会等待一些事件发生，然后调用程序去处理。最简单的事件处理是键盘敲击和鼠标滑过，或者是鼠标点击，或者是插入 USB 驱动，然后操作系统调用处理器去处理事件，更新屏幕和更新程序内部状态。这是与 UNIX 不同的设计风格。</p><p>当然，Windows 也有系统调用。在 UNIX 中，系统调用（比如 read）和系统调用所使用的调用库（例如 read）几乎是一对一的关系。而在 Windows 中，情况则大不相同。首先，函数库的调用和实际的系统调用几乎是不对应的。微软定义了一系列过程，称为 <code>Win32应用编程接口(Application Programming Interface)</code>，程序员通过这套标准的接口来实现系统调用。这个接口支持从 Windows 95 版本以来所有的 Windows 版本。</p><p>Win32 API 调用的数量是非常巨大的，有数千个多。但这些调用并不都是在内核态的模式下运行时，有一些是在用户态的模型下运行。Win32 API 有大量的调用，用来管理视窗、几何图形、文本、字体、滚动条、对话框、菜单以及 GUI 的其他功能。为了使图形子系统在内核态下运行，需要系统调用，否则就只有函数库调用。</p><p>我们把关注点放在和 Win32 系统调用中来，我们可以简单看一下 Win32 API 中的系统调用和 UNIX 中有什么不同（并不是所有的系统调用）</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133418.jpeg" srcset="/img/loading.gif" alt="img"></p><p>上表中是 UNIX 调用大致对应的 Win32 API 系统调用，简述一下上表。<code>CreateProcess</code> 用于创建一个新进程，它把 UNIX 中的 fork 和 execve 两个指令合成一个，一起执行。它有许多参数用来指定新创建进程的性质。Windows 中没有类似 UNIX 中的进程层次，所以不存在父进程和子进程的概念。在进程创建之后，创建者和被创建者是平等的。<code>WaitForSingleObject</code> 用于等待一个事件，等待的事件可以是多种可能的事件。如果有参数指定了某个进程，那么调用者将等待指定的进程退出，这通过 <code>ExitProcess</code> 来完成。</p><p>然后是6个文件操作，在功能上和 UNIX 的调用类似，然而在参数和细节上是不同的。和 UNIX 中一样，文件可以打开，读取，写入，关闭。<code>SetFilePointer</code> 和 <code>GetFileAttributesEx</code> 设置文件的位置并取得文件的属性。</p><p>Windows 中有目录，目录分别用 <code>CreateDirectory</code> 以及 <code>RemoveDirectory</code> API 调用创建和删除。也有对当前的目录的标记，这可以通过 <code>SetCurrentDirectory</code> 来设置。使用<code>GetLocalTime</code>可获得当前时间。</p><p>Win32 接口中没有文件的链接、文件系统的 mount、umount 和 stat ，当然， Win32 中也有大量 UNIX 中没有的系统调用，特别是对 GUI 的管理和调用。</p><h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><p>下面我们会探讨操作系统的几种结构，主要包括<strong>单体结构、分层系统、微内核、客户-服务端系统、虚拟机和外核</strong>等。下面以此来探讨一下</p><h3 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h3><p>到目前为止，在大多数系统中，整个系统在内核态以单一程序的方式运行。整个操作系统是以程序集合来编写的，链接在一块形成一个大的二进制可执行程序。使用此技术时，如果系统中的每个过程都提供了前者所需的一些有用的计算，则它可以自由调用任何其他过程。在单体系统中，调用任何一个所需要的程序都非常高效，但是上千个不受限制的彼此调用往往非常臃肿和笨拙，而且单体系统必然存在单体问题，那就是只要系统发生故障，那么任何系统和应用程序将不可用，这往往是灾难性的。</p><p>在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中</p><p>对于单体系统，往往有下面几种建议</p><ul><li>需要有一个主程序，用来调用请求服务程序</li><li>需要一套服务过程，用来执行系统调用</li><li>需要一套服务程序，用来辅助服务过程调用</li></ul><p>在单体系统中，对于每个系统调用都会有一个服务程序来保障和运行。需要一组实用程序来弥补服务程序需要的功能，例如从用户程序中获取数据。可将各种过程划分为一个三层模型</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133320.jpeg" srcset="/img/loading.gif" alt="img"></p><p>除了在计算机初启动时所装载的核心操作系统外，许多操作系统还支持额外的扩展。比如 I/O 设备驱动和文件系统。这些部件可以按需装载。在 UNIX 中把它们叫做 <code>共享库(shared library)</code>，在 Windows 中则被称为 <code>动态链接库(Dynamic Link Library,DLL)</code>。他们的扩展名为 <code>.dll</code>，在 <code>C:\Windows\system32</code> 目录下存在 1000 多个 DLL 文件，所以不要轻易删除 C 盘文件，否则可能就炸了哦。</p><h3 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h3><p>分层系统使用层来分隔不同的功能单元。每一层只与该层的上层和下层通信。每一层都使用下面的层来执行其功能。层之间的通信通过预定义的固定接口通信。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133342.png" srcset="/img/loading.gif" alt="img"></p><p>分层系统是由 <code>E.W.Dijkstar</code> 和他的学生在荷兰技术学院所开发的 THE 系统。</p><p>把上面单体系统进一步通用化，就变为了一个层次式结构的操作系统，它的上层软件都是在下层软件的基础之上构建的。该系统分为六层，如下所示</p><table><thead><tr><th align="left">层号</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">5</td><td align="left">操作员</td></tr><tr><td align="left">4</td><td align="left">用户程序</td></tr><tr><td align="left">3</td><td align="left">输入/输出管理</td></tr><tr><td align="left">2</td><td align="left">操作员-进程通信</td></tr><tr><td align="left">1</td><td align="left">存储器和磁鼓管理</td></tr><tr><td align="left">0</td><td align="left">处理器分配和多道程序编程</td></tr></tbody></table><p>处理器在 0 层运行，当中断发生或定时器到期时，由该层完成进程切换；在第 0 层之上，系统由一些连续的进程组成，编写这些进程时不用再考虑在单处理器上多进程运行的细节。内存管理在第 1 层，它分配进程的主存空间。第 1 层软件保证一旦需要访问某一页面，该页面必定已经在内存中，并且在页面不需要的时候将其移出。</p><p>第 2 层处理进程与操作员控制台（即用户）之间的通信。第 3 层管理 I/O 设备和相关的信息流缓冲区。第 4 层是用户程序层，用户程序不用考虑进程、内存、控制台或 I/O 设备管理等细节。系统操作员在第 5 层。</p><h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>在分层方式中，设计者要确定在哪里划分 <code>内核-用户</code> 的边界。传统上，所有的层都在内核中，但是这样做没有必要。事实上，尽可能减少内核态中功能可能是更好的做法。因为内核中的错误很难处理，一旦内核态中出错误会拖累整个系统。</p><p>所以，为了实现高可靠性，将操作系统划分成小的、层级之间能够更好定义的模块是很有必要的，只有一个模块 — 微内核 — 运行在内核态，其余模块可以作为普通用户进程运行。由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使整个系统死机。</p><p><code>MINIX 3</code> 是微内核的代表作，它的具体结构如下</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133349.jpeg" srcset="/img/loading.gif" alt="img"></p><p>在内核的外部，系统的构造有三层，它们都在用户态下运行，最底层是设备驱动器。由于它们都在用户态下运行，所以不能物理的访问 I/O 端口空间，也不能直接发出 I/O 命令。相反，为了能够对 I/O 设备编程，驱动器构建一个结构，指明哪个参数值写到哪个 I/O 端口，并声称一个内核调用，这样就完成了一次调用过程。</p><p>位于用户态的驱动程序上面是<code>服务器</code>层，包含有服务器，它们完成操作系统的多数工作。由一个或多个文件服务器管理着文件系统，进程管理器创建、销毁和管理进程。服务器中有一个特殊的服务器称为 <code>再生服务器(reincarnation server)</code>，它的任务就是检查服务器和驱动程序的功能是否正确，一旦检查出来错误，它就会补上去，无需用户干预。这种方式使得系统具有可恢复性，并具有较高的可靠性。</p><p>微内核中的内核还具有一种 <code>机制</code> 与 <code>策略</code> 分离的思想。比如系统调度，一个比较简单的调度算法是，对每个进程赋予一个优先级，并让内核执行具有最高优先级的进程。这里，内核机制就是寻找最高的优先级进程并运行。而策略（赋予进程优先级）可以在用户态中的进程完成。在这种模式中，策略和机制是分离的，从而使内核变得更小。</p><h3 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户-服务器模式"></a>客户-服务器模式</h3><p>微内核思想的策略是把进程划分为两类：<code>服务器</code>，每个服务器用来提供服务；<code>客户端</code>，使用这些服务。这个模式就是所谓的 <code>客户-服务器</code>模式。</p><p>客户-服务器模式会有两种载体，一种情况是一台计算机既是客户又是服务器，在这种方式下，操作系统会有某种优化；但是普遍情况下是客户端和服务器在不同的机器上，它们通过局域网或广域网连接。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715133357.jpeg" srcset="/img/loading.gif" alt="img"></p><p>客户通过发送消息与服务器通信，客户端并不需要知道这些消息是在本地机器上处理，还是通过网络被送到远程机器上处理。对于客户端而言，这两种情形是一样的：都是发送请求并得到回应。</p><p>越来越多的系统，包括家里的 PC，都成为客户端，而在某地运行的大型机器则成为服务器。许多 web 就是以这种方式运行的。一台 PC 向某个服务器请求一个 Web 页面，服务器把 Web 页面返回给客户端，这就是典型的客服-服务器模式</p><p>文章参考：</p><p>《现代操作系统》第四版</p><p><a href="https://baike.baidu.com/item/操作系统/192?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/操作系统/192?fr=aladdin</a></p><p>《Modern Operating System》forth edition</p><p><a href="http://faculty.cs.niu.edu/~hutchins/csci360/hchnotes/psw.htm" target="_blank" rel="noopener">http://faculty.cs.niu.edu/~hutchins/csci360/hchnotes/psw.htm</a></p><p><a href="https://www.computerhope.com/jargon/c/clockcyc.htm" target="_blank" rel="noopener">https://www.computerhope.com/jargon/c/clockcyc.htm</a></p><p>《B站-操作系统》</p><p><a href="https://www.bilibili.com/video/av9555596?from=search&amp;seid=8107077283516919308" target="_blank" rel="noopener">https://www.bilibili.com/video/av9555596?from=search&amp;seid=8107077283516919308</a></p><p><a href="https://en.wikipedia.org/wiki/System_call" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/System_call</a></p><p><a href="http://c.biancheng.net/cpp/html/238.html" target="_blank" rel="noopener">http://c.biancheng.net/cpp/html/238.html</a></p><p><a href="http://www.dossier-andreas.net/software_architecture/layers.html" target="_blank" rel="noopener">http://www.dossier-andreas.net/software_architecture/layers.html</a></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在线学习网站，刷题学习 Git/SQL/正则表达式</title>
    <link href="/2020/07/12/20:24.html"/>
    <url>/2020/07/12/20:24.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p>原创 labuladong </p>          </div><p>对于技术的学习，我经常面临的困境是，<strong>理论知识知道的不少，但是有的场景实在无法模拟，缺少亲自动手实践的机会</strong>，如果能有一本带标准答案的习题册让我刷刷就好了。</p><p>所以在学习新技术时，我首先会去搜索是否有在线刷题平台，你还别说，有的大神真就做了很不错的在线练习平台。下面就介绍几个平台，分别是学习 Git、SQL、正则表达式的在线练习平台。</p><h2 id="一、练习-Git"><a href="#一、练习-Git" class="headerlink" title="一、练习 Git"></a>一、练习 Git</h2><p>这是个叫做 Learning Git Branching 的项目，是我一定要推荐的：</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714213835.jpeg" srcset="/img/loading.gif" alt="img"></p><p>正如对话框中的自我介绍，这确实也是我至今发现的<strong>最好</strong>的 Git 动画教程，没有之一。</p><p>想当年我用 Git 就会 <code>add .</code>，<code>clone</code>，<code>push</code>，<code>pull</code>，<code>commit</code> 几个命令，其他的命令完全不会，Git 就是一个下载器，Github 就是个资源网站加免费图床，命令能不能达成目的都是靠运气。什么版本控制，我根本搞不懂，也懒得去看那一堆乱七八糟的文档。</p><p>这个网站的教程不是给你举那种修改文件的细节例子，而是将每次 <code>commit</code> 都抽象成树的节点，<strong>用动画闯关的形式</strong>，让你自由使用 Git 命令完成目标：</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714213836.jpeg" srcset="/img/loading.gif" alt="img"></p><p>所有 Git 分支都被可视化了，你只要在左侧的命令行输入 Git 命令，分支会进行相应的变化，只要达成任务目标，你就过关啦！网站还会记录你的命令数，试试能不能以最少的命令数过关！</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200716154903.jpeg" srcset="/img/loading.gif" alt="img"></p><p>我一开始以为这个教程只包含本地 Git 仓库的版本管理，<strong>后来我惊奇地发现它还有远程仓库的操作教程</strong>！</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714213839.jpeg" srcset="/img/loading.gif" alt="img"></p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200716154924.png" srcset="/img/loading.gif" alt="img"></p><p>真的跟玩游戏一样，难度设计合理，流畅度很好，我一玩都停不下来了，几小时就打通了，哈哈哈！</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200716154834.jpeg" srcset="/img/loading.gif" alt></p><p>总之，这个教程很适合初学和进阶，如果你觉得自己对 Git 的掌握还不太好，用 Git 命令还是有运气成分，就可以玩玩这个教程，相信能够让你更熟练地使用 Git。</p><p>它是一个开源项目，Github 项目地址：</p><p><a href="https://github.com/pcottle/learnGitBranching" target="_blank" rel="noopener">https://github.com/pcottle/learnGitBranching</a></p><p>教程网站地址：</p><p><a href="https://learngitbranching.js.org" target="_blank" rel="noopener">https://learngitbranching.js.org</a></p><h2 id="二、练习正则表达式"><a href="#二、练习正则表达式" class="headerlink" title="二、练习正则表达式"></a>二、练习正则表达式</h2><p><strong>正则表达式是个非常强有力的工具</strong>，可以说计算机中的一切数据都是字符，借助正则表达式这种模式匹配工具，操作计算机可以说是如虎添翼。</p><p>我这里要推荐两个网站，一个是练习平台，一个是测试正则表达式的平台。</p><p>先说练习平台，叫做 RegexOne：</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200716155019.jpeg" srcset="/img/loading.gif" alt="img"></p><p>前面有基本教程，后面有一些常见的正则表达式题目，比如判断邮箱、URL、电话号，或者抽取日志的关键信息等等。</p><p>只要写出符合要求的正则表达式，就可以进入下一个问题，关键是每道题还有标准答案，可以点击下面的 solution 按钮查看：</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200716155027.jpeg" srcset="/img/loading.gif" alt="img"></p><p>RegexOne 网址：</p><p><a href="https://regexone.com/" target="_blank" rel="noopener">https://regexone.com/</a></p><p>再说测试工具，是个叫做 RegExr 的 Github 项目，这是它的网站：</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714213843.jpeg" srcset="/img/loading.gif" alt="img"></p><p>可以看见，输入文本和正则模式串后，<strong>网站会给正则表达式添加漂亮且容易辨认的样式，自动在文本中搜索模式串，高亮显示匹配的字符串，并且还会显示每个分组捕获的字符串，下方还会给出每个通配符的含义</strong>。</p><p>这个网站可以配合前面的正则练习平台使用，在这里尝试各种表达式，成功匹配之后粘贴过去。</p><p>RegExr 网址：</p><p><a href="https://regexr.com/" target="_blank" rel="noopener">https://regexr.com/</a></p><h2 id="三、练习-SQL"><a href="#三、练习-SQL" class="headerlink" title="三、练习 SQL"></a>三、练习 SQL</h2><p>这是一个叫做 SQLZOO 的网站，左侧是所有的练习内容：</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714213844.jpeg" srcset="/img/loading.gif" alt="img"></p><p>SQLZOO 是一款很好用的 SQL 练习平台，英文不难理解，可以直接看英文版，但是也可以切换繁体中文，比较友好。</p><p>这里都是比较常用的 SQL 命令，给你一个需求，你写 SQL 语句实现正确的查询结果。<strong>最重要的是，这里不仅对每个命令的用法有详细解释，每个专题后面还有选择题（quiz），而且有判题系统，甚至有的比较难的题目还有视频讲解</strong>：</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714213845.jpeg" srcset="/img/loading.gif" alt="img"></p><p>至于难度，循序渐进，即便对新手也很友好，靠后的问题确实比较有技巧性，相信这是热爱思维挑战的人喜欢的！LeetCode 也有 SQL 相关的题目，不过难度一般比较大，我觉得 SQLZOO 刷完基础 SQL 命令再去 LeetCode 刷比较合适。</p><p>网站地址：</p><p><a href="https://sqlzoo.net/" target="_blank" rel="noopener">https://sqlzoo.net/</a></p><p>以上就是我想推荐的几个网站，没有什么技术是刷题学不会的，如果有，就多刷一些！</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
      <category>SQL</category>
      
      <category>正则表达式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git练习</tag>
      
      <tag>SQL</tag>
      
      <tag>正则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工作流一目了然，用动图展示10大Git命令</title>
    <link href="/2020/07/12/19:24.html"/>
    <url>/2020/07/12/19:24.html</url>
    
    <content type="html"><![CDATA[<p>git merge、git rebase、git reset、git revert、git fetch、git pull、git reflog……你知道这些 git 命令执行的究竟是什么任务吗？如果你还有些分不清楚，那千万不能错过这篇文章。在本文中，21 岁年轻软件顾问 Lydia Hallie 通过动图形式直观地介绍了这些常用 git 命令的工作过程，包你过目不忘。</p><a id="more"></a><div class="note note-success">            <p>转自公众号：机器之心</p><p>整理：五分钟学算法</p><p> 原文：<a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1" target="_blank" rel="noopener">https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1</a></p>          </div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714170159.png" srcset="/img/loading.gif" alt="img"></p><p>尽管 Git 是一款非常强大的工具，但如果我说 Git 用起来简直是噩梦，大多数人也会认同我的说法。我们前文 <a href="https://www.yossi.top/2020/07/12/刷题学习-GitSQL正则表达式/" target="_blank" rel="noopener">一起刷题学习 Git/SQL/正则表达式</a> 专门介绍了一个很好用的在线练习 Git 命令的网站，没看过的一定要看看，去刷一波。</p><p>我发现在使用 Git 时，在头脑里可视化地想象它会非常有用：当我执行一个特定命令时，这些分支会如何交互，又会怎样影响历史记录？为什么当我在 master 上执行硬重启，force push 到原分支以及 rimraf 我们的 .git 文件夹时，我的同事哭了？</p><p>我觉得创建一些最常用且最有用的 Git 命令的可视化示例会是一个完美的用例！下面我将介绍的很多命令都有可选参数——你可以使用这些参数来改变对应命令的行为。而我的示例只会涵盖命令的默认行为，而不会添加（或添加太多）可选配置！</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714170200.jpeg" srcset="/img/loading.gif" alt="img"></p><p>本文作者：Lydia Hallie</p><h2 id="合并（merge）"><a href="#合并（merge）" class="headerlink" title="合并（merge）"></a>合并（merge）</h2><p>拥有多个分支是很方便的，这样可以将不同的新修改互相隔离开，而且还能确保你不会意外地向生产代码推送未经许可或破损的代码修改。但一旦这些修改得到了批准许可，我们就需要将其部署到我们的生产分支中！</p><p>可将一个分支的修改融入到另一个分支的一种方式是执行 git merge。Git 可执行两种类型的合并：fast-forward 和 no-fast-forward。现在你可能分不清，但我们马上就来看看它们的差异所在。</p><h3 id="Fast-forward-—ff"><a href="#Fast-forward-—ff" class="headerlink" title="Fast-forward (—ff)"></a>Fast-forward (—ff)</h3><p>在当前分支相比于我们要合并的分支没有额外的提交（commit）时，可以执行 fast-forward 合并。Git 很懒，首先会尝试执行最简单的选项：fast-forward！这类合并不会创建新的提交，而是会将我们正在合并的分支上的提交直接合并到当前分支。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715124323.gif" srcset="/img/loading.gif" alt="img"></p><p>完美！现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。那么 no-fast-forward 又是什么意思呢？</p><h3 id="No-fast-foward-—no-ff"><a href="#No-fast-foward-—no-ff" class="headerlink" title="No-fast-foward (—no-ff)"></a>No-fast-foward (—no-ff)</h3><p>如果你的当前分支相比于你想要合并的分支没有任何提交，那当然很好，但很遗憾现实情况很少如此！如果我们在当前分支上提交我们想要合并的分支不具备的改变，那么 git 将会执行 no-fast-forward 合并。</p><p>使用 no-fast-forward 合并时，Git 会在当前活动分支上创建新的 merging commit。这个提交的父提交（parent commit）即指向这个活动分支，也指向我们想要合并的分支！</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715124333.gif" srcset="/img/loading.gif" alt="img"></p><p>没什么大不了的，完美的合并！现在，我们在 dev 分支上所做的所有改变都合并到了 master 分支上。</p><h3 id="合并冲突（conflict）"><a href="#合并冲突（conflict）" class="headerlink" title="合并冲突（conflict）"></a>合并冲突（conflict）</h3><p>尽管 Git 能够很好地决定如何合并分支以及如何向文件添加修改，但它并不总是能完全自己做决定。当我们想要合并的两个分支的同一文件中的同一行代码上有不同的修改，或者一个分支删除了一个文件而另一个分支修改了这个文件时，Git 就不知道如何取舍了。</p><p>在这样的情况下，Git 会询问你想要保留哪种选择？假设在这两个分支中，我们都编辑了 README.md 的第一行。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715124343.png" srcset="/img/loading.gif" alt="img"></p><p>如果我们想把 dev 合并到 master，就会出现一个合并冲突：你想要标题是 Hello! 还是 Hey!？</p><p>当尝试合并这些分支时，Git 会向你展示冲突出现的位置。我们可以手动移除我们不想保留的修改，保存这些修改，再次添加这个已修改的文件，然后提交这些修改。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715124353.gif" srcset="/img/loading.gif" alt="img"></p><p>完成！尽管合并冲突往往很让人厌烦，但这是合理的：Git 不应该瞎猜我们想要保留哪些修改。</p><h2 id="变基（Rebasing）"><a href="#变基（Rebasing）" class="headerlink" title="变基（Rebasing）"></a>变基（Rebasing）</h2><p>我们刚看到可通过执行 git merge 将一个分支的修改应用到另一个分支。另一种可将一个分支的修改融入到另一个分支的方式是执行 git rebase。</p><p>git rebase 会将当前分支的提交复制到指定的分支之上。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715124402.gif" srcset="/img/loading.gif" alt="img"></p><p>完美，现在我们在 dev 分支上获取了 master 分支上的所有修改。</p><p>变基与合并有一个重大的区别：Git 不会尝试确定要保留或不保留哪些文件。我们执行 rebase 的分支总是含有我们想要保留的最新近的修改！这样我们不会遇到任何合并冲突，而且可以保留一个漂亮的、线性的 Git 历史记录。</p><p>上面这个例子展示了在 master 分支上的变基。但是，在更大型的项目中，你通常不需要这样的操作。git rebase 在为复制的提交创建新的 hash 时会修改项目的历史记录。</p><p>如果你在开发一个 feature 分支并且 master 分支已经更新过，那么变基就很好用。你可以在你的分支上获取所有更新，这能防止未来出现合并冲突。</p><h3 id="交互式变基（Interactive-Rebase）"><a href="#交互式变基（Interactive-Rebase）" class="headerlink" title="交互式变基（Interactive Rebase）"></a>交互式变基（Interactive Rebase）</h3><p>在为提交执行变基之前，我们可以修改它们！我们可以使用交互式变基来完成这一任务。交互式变基在你当前开发的分支上以及想要修改某些提交时会很有用。</p><p>在我们正在 rebase 的提交上，我们可以执行以下 6 个动作：</p><ul><li>reword：修改提交信息；</li><li>edit：修改此提交；</li><li>squash：将提交融合到前一个提交中；</li><li>fixup：将提交融合到前一个提交中，不保留该提交的日志消息；</li><li>exec：在每个提交上运行我们想要 rebase 的命令；</li><li>drop：移除该提交。</li></ul><p>很棒！这样我们就能完全控制我们的提交了。如果你想要移除一个提交，只需 drop 即可。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715124412.gif" srcset="/img/loading.gif" alt="img"></p><p>如果你想把多个提交融合到一起以便得到清晰的提交历史，那也没有问题！</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715124419.gif" srcset="/img/loading.gif" alt="img"></p><p>交互式变基能为你在 rebase 时提供大量控制，甚至可以控制当前的活动分支。</p><h2 id="重置（Resetting）"><a href="#重置（Resetting）" class="headerlink" title="重置（Resetting）"></a>重置（Resetting）</h2><p>当我们不想要之前提交的修改时，就会用到这个命令。也许这是一个 WIP 提交或者可能是引入了 bug 的提交，这时候就要执行 git reset。</p><p>git reset 能让我们不再使用当前台面上的文件，让我们可以控制 HEAD 应该指向的位置。</p><h3 id="软重置"><a href="#软重置" class="headerlink" title="软重置"></a>软重置</h3><p>软重置会将 HEAD 移至指定的提交（或与 HEAD 相比的提交的索引），而不会移除该提交之后加入的修改！</p><p>假设我们不想保留添加了一个 style.css 文件的提交 9e78i，而且我们也不想保留添加了一个 index.js 文件的提交 035cc。但是，我们确实又想要保留新添加的 style.css 和 index.js 文件！这是软重置的一个完美用例。</p><p> <img src="https://gitee.com/yossi/picture/raw/master/img/20200715122806.gif" srcset="/img/loading.gif" alt="img"></p><p>输入 git status 后，你会看到我们仍然可以访问在之前的提交上做过的所有修改。这很好，这意味着我们可以修复这些文件的内容，之后再重新提交它们！</p><h3 id="硬重置"><a href="#硬重置" class="headerlink" title="硬重置"></a>硬重置</h3><p>有时候我们并不想保留特定提交引入的修改。不同于软重置，我们应该再也无需访问它们。Git 应该直接将整体状态直接重置到特定提交之前的状态：这甚至包括你在工作目录中和暂存文件上的修改。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715122727.gif" srcset="/img/loading.gif" alt="img"></p><p>Git 丢弃了 9e78i 和 035cc 引入的修改，并将状态重置到了 ec5be 的状态。</p><h2 id="还原（Reverting）"><a href="#还原（Reverting）" class="headerlink" title="还原（Reverting）"></a>还原（Reverting）</h2><p>另一种撤销修改的方法是执行 git revert。通过对特定的提交执行还原操作，我们会创建一个包含已还原修改的新提交。</p><p>假设 ec5be 添加了一个 index.js 文件。但之后我们发现其实我们再也不需要由这个提交引入的修改了。那就还原 ec5be 提交吧！</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715122913.gif" srcset="/img/loading.gif" alt="img"></p><p>完美！提交 9e78i 还原了由提交 ec5be 引入的修改。在撤销特定的提交时，git revert 非常有用，同时也不会修改分支的历史。</p><h2 id="拣选（Cherry-picking）"><a href="#拣选（Cherry-picking）" class="headerlink" title="拣选（Cherry-picking）"></a>拣选（Cherry-picking）</h2><p>当一个特定分支包含我们的活动分支需要的某个提交时，我们对那个提交执行 cherry-pick！对一个提交执行 cherry-pick 时，我们会在活动分支上创建一个新的提交，其中包含由拣选出来的提交所引入的修改。</p><p>假设 dev 分支上的提交 76d12 为 index.js 文件添加了一项修改，而我们希望将其整合到 master 分支中。我们并不想要整个 dev 分支，而只需要这个提交！</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714170209.gif" srcset="/img/loading.gif" alt="img"></p><p>现在 master 分支包含 76d12 引入的修改了。</p><h2 id="取回（Fetching）"><a href="#取回（Fetching）" class="headerlink" title="取回（Fetching）"></a>取回（Fetching）</h2><p>如果你有一个远程 Git 分支，比如在 GitHub 上的分支，当远程分支上包含当前分支没有的提交时，可以使用取回。比如当合并了另一个分支或你的同事推送了一个快速修复时。</p><p>通过在这个远程分支上执行 git fetch，我们就可在本地获取这些修改。这不会以任何方式影响你的本地分支：fetch 只是单纯地下载新的数据而已。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200715123034.gif" srcset="/img/loading.gif" alt="img"></p><p>现在我们可以看到自上次推送以来的所有修改了。这些新数据也已经在本地了，我们可以决定用这些新数据做什么了。</p><h2 id="拉取（Pulling）"><a href="#拉取（Pulling）" class="headerlink" title="拉取（Pulling）"></a>拉取（Pulling）</h2><p>尽管 git fetch 可用于获取某个分支的远程信息，但我们也可以执行 git pull。git pull 实际上是两个命令合成了一个：git fetch 和 git merge。当我们从来源拉取修改时，我们首先是像 git fetch 那样取回所有数据，然后最新的修改会自动合并到本地分支中。</p><p><img src="/child/2020/07/12/19:24/youxi/Desktop/hexo/img/20200714170210.gif" srcset="/img/loading.gif" alt="img"></p><p>很好，我们现在与远程分支完美同步了，并且也有了所有最新的修改！</p><h2 id="Reflog"><a href="#Reflog" class="headerlink" title="Reflog"></a>Reflog</h2><p>每个人都会犯错，但犯错其实没啥！有时候你可能感觉你把 git repo 完全搞坏了，让你想完全删了了事。</p><p>git reflog 是一个非常有用的命令，可以展示已经执行过的所有动作的日志。包括合并、重置、还原，基本上包含你对你的分支所做的任何修改。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714170212.gif" srcset="/img/loading.gif" alt="img"></p><p>如果你犯了错，你可以根据 reflog 提供的信息通过重置 HEAD 来轻松地重做！</p><p>假设我们实际上并不需要合并原有分支。当我们执行 git reflog 命令时，我们可以看到这个 repo 的状态在合并前位于 HEAD@{1}。那我们就执行一次 git reset，将 HEAD 重新指向在 HEAD@{1} 的位置。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714170213.gif" srcset="/img/loading.gif" alt="img"></p><p><strong>我们可以看到最新的动作已被推送给 reflog。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用四个命令总结 Git 的所有套路</title>
    <link href="/2020/07/12/09:24.html"/>
    <url>/2020/07/12/09:24.html</url>
    
    <content type="html"><![CDATA[<p>使用Git搞不明白的一个重要原因就是，命令的功能太杂，有时候一个需求可以用好几种命令解决，而且有的命令还有别名。这导致什么问题呢，我在网上找到的答案五花八门，竟然都能达成目的，难以找到规律，毫无套路可言。对于我这种不喜欢动脑子，只喜欢玩套路的人来说，简直不能接受。</p><a id="more"></a><div class="note note-success">            <p>转载自公众号：<a href="https://mp.weixin.qq.com/s/VdeQpFCL3GGsfOKrIRW6Hw" target="_blank" rel="noopener">labuladong</a> </p>          </div> <hr><p>以前我用 Git，就知道<code>add .</code>，然后<code>commit -m</code>，最后<code>push origin master</code>一套带走，或者就是把 Git 作为下载器，去<code>clone</code>别人的项目。但是在工作中呢，和别人一起开发代码，就需要处理一些复杂情况，比如解决冲突，比如手残恢复，等等等实用场景，这些我在后文都会列举。</p><p>对于工具的学习，我认为应该多做减法，只捡最有用的学，那些奇技淫巧不学也罢，应该把时间投入更有价值的事情中。</p><p><strong>所以本文不是一个大而全 Git 命令的使用手册，而是根据实际工作中最常见问题，提供小而美的解决方案，仅仅涉及四个命令：<code>add</code>，<code>commit</code>，<code>reset</code>，<code>checkout</code></strong>。</p><p>PS： <a href="https://www.yossi.top/2020/07/12/刷题学习-GitSQL正则表达式/" target="_blank" rel="noopener">一起刷题学习 Git/SQL/正则表达式 </a>介绍了一个可视化学习 Git 的网站，非常优秀，值得一刷。</p><h3 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h3><p>首先，在进入 Git 的各种神仙操作之前，<strong>一定要明白 git 的三个「分区」是什么，否则的话你一定没办法真正理解 Git 的原理</strong>。</p><p>本地 Git 的三个分区分别是：<code>working directory</code>，<code>stage/index area</code>，<code>commit history</code>。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714161344.png" srcset="/img/loading.gif" alt="https://rogerdudler.github.io/git-guide"><a href="https://rogerdudler.github.io/git-guide" target="_blank" rel="noopener">https://rogerdudler.github.io/git-guide</a></p><p><strong><code>working directory</code>是「工作目录」，也就是我们肉眼能够看到的文件</strong>，后文我们称其为<code>work dir</code>区。</p><p>当我们在<code>work dir</code>中<strong>执行<code>git add</code>相关命令后，就会把<code>work dir</code>中的修改添加到「暂存区」<code>stage area</code>（或者叫<code>index area</code>）中去</strong>，后文我们称暂存区为<code>stage</code><br>区。</p><p>当<code>stage</code>中存在修改时，我们<strong>使用<code>git commit</code>相关命令之后，就会把<code>stage</code>中的修改保存到「提交历史」<code>commit history</code>中</strong>，也就是<code>HEAD</code>指针指向的位置。后文我们称「提交历史」为<code>history</code>区。</p><p>关于<code>commit history</code>我们多说几句，任何修改只要进入<code>commit history</code>，基本可以认为永远不会丢失了。每个<code>commit</code>都有一个唯一的 Hash 值，我们经常说的<code>HEAD</code>或者<code>master</code>分支，都可以理解为一个指向某个<code>commit</code>的指针。</p><p><code>work dir</code>和<code>stage</code>区域的状态，可以通过命令<code>git status</code>来查看，<code>history</code>区域的提交历史可以通过<code>git log</code>命令来查看。</p><p>好的，如果上面的内容你都能够理解，那么本文就完全围绕这三个概念展开，下面就是一个「状态转移图」：</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714161345.jpeg" srcset="/img/loading.gif" alt="img"></p><h3 id="二、本地-Git-极简教程"><a href="#二、本地-Git-极简教程" class="headerlink" title="二、本地 Git 极简教程"></a>二、本地 Git 极简教程</h3><p><strong>需求一，如何把<code>work dir</code>中的修改加入<code>stage</code></strong>。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714161346.jpeg" srcset="/img/loading.gif" alt="img"></p><p>这个是最简单，使用 <strong><code>git add</code></strong> 相关的命令就行了。顺便一提，<code>add</code>有个别名叫做<code>stage</code>，也就是说你可能见到<code>git stage</code>相关的命令，这个命令和<code>git add</code>命令是完全一样的。</p><p><strong>风险等级：无风险。</strong></p><p>理由：不会改变任或撤销任何已作出的修改，而且还会将<code>work dir</code>中未追踪的修改（Untracked file）添加到暂存区<code>stage</code>中进行追踪。</p><p><strong>需求二，如何把<code>stage</code>中的修改还原到<code>work dir</code>中</strong>。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714161347.jpeg" srcset="/img/loading.gif" alt="img"></p><p>这个需求很常见，也很重要，比如我先将当前<code>work dir</code>中的修改添加到<code>stage</code>中，然后又对<code>work dir</code>中的文件进行了修改，但是又后悔了，如何把<code>work dir</code>中的全部或部分文件还原成<code>stage</code>中的样子呢？</p><p>来个实际场景，我先新建两个文件，然后把他们都加到<code>stage</code>：</p><div class="hljs"><pre><code class="hljs livecodeserver">$ touch <span class="hljs-keyword">a</span>.txt b.txt$ git <span class="hljs-built_in">add</span> .$ git statusOn branch masterChanges <span class="hljs-built_in">to</span> be committed:    <span class="hljs-built_in">new</span> <span class="hljs-built_in">file</span>:   <span class="hljs-keyword">a</span>.txt    <span class="hljs-built_in">new</span> <span class="hljs-built_in">file</span>:   b.txt</code></pre></div><p>然后我又修改了<code>a.txt</code>文件：</p><div class="hljs"><pre><code class="hljs livecodeserver">$ echo hello world &gt;&gt; <span class="hljs-keyword">a</span>.txt$ git statusOn branch masterChanges <span class="hljs-built_in">to</span> be committed:    <span class="hljs-built_in">new</span> <span class="hljs-built_in">file</span>:   <span class="hljs-keyword">a</span>.txt    <span class="hljs-built_in">new</span> <span class="hljs-built_in">file</span>:   b.txtChanges <span class="hljs-keyword">not</span> staged <span class="hljs-keyword">for</span> commit:    modified:   <span class="hljs-keyword">a</span>.txt</code></pre></div><p>现在，我后悔了，我认为不应该修改<code>a.txt</code>，我想把它还原成<code>stage</code>中的空文件，怎么办？</p><p>答案是，使用 <strong><code>checkout</code></strong> 命令：</p><div class="hljs"><pre><code class="hljs livecodeserver">$ git checkout <span class="hljs-keyword">a</span>.txtUpdated <span class="hljs-number">1</span> path <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> index$ git statusOn branch masterChanges <span class="hljs-built_in">to</span> be committed:    <span class="hljs-built_in">new</span> <span class="hljs-built_in">file</span>:   <span class="hljs-keyword">a</span>.txt    <span class="hljs-built_in">new</span> <span class="hljs-built_in">file</span>:   b.txt</code></pre></div><p>看到了么，输出显示从<code>index</code>区（也就是<code>stage</code>区）更新了一个文件，也就是把<code>work dir</code>中<code>a.txt</code>文件还原成了<code>stage</code>中的状态（一个空文件）。</p><p>当然，如果<code>work dir</code>中被修改的文件很多，可以使用通配符全部恢复成<code>stage</code>：</p><div class="hljs"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git checkout .</code></pre></div><p>有一点需要指出的是，<code>checkout</code>命令只会把被「修改」的文件恢复成<code>stage</code>的状态，如果<code>work dir</code>中新增了新文件，你使用<code>git checkout .</code>是不会删除新文件的。</p><p><strong>风险等级：中风险。</strong></p><p>理由：在<code>work dir</code>做出的「修改」会被<code>stage</code>覆盖，无法恢复。所以使用该命令你应该确定<code>work dir</code>中的修改可以抛弃。</p><p><strong>需求三，将<code>stage</code>区的文件添加到<code>history</code>区</strong>。</p><p><img src="/child/2020/07/12/09:24/youxi/Desktop/hexo/img/20200714161346.jpeg" srcset="/img/loading.gif" alt="img"></p><p>很简单，就是 <strong><code>git commit</code></strong> 相关的命令，一般我们就是这样用的：</p><div class="hljs"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">'一些描述'</span></code></pre></div><p>再简单提一些常见场景， 比如说<code>commit</code>完之后，突然发现一些错别字需要修改，又不想为改几个错别字而新开一个<code>commit</code>到<code>history</code>区，那么就可以使用下面这个命令：</p><div class="hljs"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">commit</span> <span class="hljs-comment">--amend</span></code></pre></div><p>这样就是把错别字的修改和之前的那个<code>commit</code>中的修改合并，作为一个<code>commit</code>提交到<code>history</code>区。</p><p><strong>风险等级：无风险。</strong></p><p>理由：不会改变任或撤销任何已作出的修改，而且还会将<code>stage</code>区的修改加入<code>history</code>区并分配一个 Hash 值。只要不乱动本地的<code>.git</code>文件夹，进入<code>history</code>的修改就永远不会丢失。</p><p><strong>需求四，将<code>history</code>区的文件还原到<code>stage</code>区</strong>。</p><p><img src="/child/2020/07/12/09:24/youxi/Desktop/hexo/img/20200714161346-20200715102550918.jpeg" srcset="/img/loading.gif" alt="img"></p><p>这个需求很常见，比如说我用了一个<code>git add .</code>一股脑把所有修改加入<code>stage</code>，但是突然想起来文件<code>a.txt</code>中的代码我还没写完，不应该把它<code>commit</code>到<code>history</code>区，所以我得把它从<code>stage</code>中撤销，等后面我写完了再提交。</p><div class="hljs"><pre><code class="hljs routeros">$ echo<span class="hljs-built_in"> aaa </span>&gt;&gt; a.txt; echo bbb &gt;&gt; b.txt;$ git <span class="hljs-builtin-name">add</span> .$ git statusOn branch masterChanges <span class="hljs-keyword">to</span> be committed:    modified:   a.txt    modified:   b.txt</code></pre></div><p>如何把<code>a.txt</code>从<code>stage</code>区还原出来呢？可以使用 <strong><code>git reset</code></strong> 命令：</p><div class="hljs"><pre><code class="hljs sql">$ git <span class="hljs-keyword">reset</span> a.txt$ git <span class="hljs-keyword">status</span><span class="hljs-keyword">On</span> branch <span class="hljs-keyword">master</span>Changes <span class="hljs-keyword">to</span> be committed:    modified:   b.txtChanges <span class="hljs-keyword">not</span> staged <span class="hljs-keyword">for</span> <span class="hljs-keyword">commit</span>:    modified:   a.txt</code></pre></div><p>你看，这样就可以把<code>a.txt</code>文件从<code>stage</code>区移出，这时候进行<code>git commit</code>相关的操作就不会把这个文件一起提交到<code>history</code>区了。</p><p>上面的这个命令是一个简写，实际上<code>reset</code>命令的完整写法如下：</p><div class="hljs"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--mixed HEAD a.txt</span></code></pre></div><p>其中，<code>mixed</code>是一个模式（mode）参数，如果<code>reset</code>省略这个选项的话默认是<code>mixed</code>模式；<code>HEAD</code>指定了一个历史提交的 hash 值；<code>a.txt</code>指定了一个或者多个文件。</p><p><strong>该命令的自然语言描述是：不改变<code>work dir</code>中的任何数据，将<code>stage</code>区域中的<code>a.txt</code>文件还原成<code>HEAD</code>指向的<code>commit history</code>中的样子</strong>。就相当于把对<code>a.txt</code>的修改从<code>stage</code>区撤销，但依然保存在<code>work dir</code>中，变为<code>unstage</code>的状态。</p><p><strong>风险等级：低风险。</strong></p><p>理由：不会改变<code>work dir</code>中的数据，会改变<code>stage</code>区的数据，所以应确保<code>stage</code>中被改动数据是可以抛弃的。</p><p><strong>需求五，将<code>work dir</code>的修改提交到<code>history</code>区</strong>。</p><p><img src="/child/2020/07/12/09:24/youxi/Desktop/hexo/img/20200714161346-20200715102642324.jpeg" srcset="/img/loading.gif" alt="img"></p><p>这个需求很简单啦，先<code>git add</code>然后<code>git commit</code>就行了，或者一个快捷方法是使用命令<code>git commit -a</code>。</p><p><strong>风险等级：无风险。</strong></p><p>理由：显而易见。</p><p><strong>需求六，将<code>history</code>区的历史提交还原到<code>work dir</code>中</strong>。</p><p><img src="/child/2020/07/12/09:24/youxi/Desktop/hexo/img/20200714161346-20200715102648004.jpeg" srcset="/img/loading.gif" alt="img"></p><p>这个场景，我说一个极端一点的例子：比如我从 GitHub 上<code>clone</code>了一个项目，然后乱改了一通代码，结果发现我写的代码根本跑不通，于是后悔了，干脆不改了，我想恢复成最初的模样，怎么办？</p><p>依然是使用<code>checkout</code>命令，但是和之前的使用方式有一些不同：</p><div class="hljs"><pre><code class="hljs angelscript">$ git checkout HEAD .Updated <span class="hljs-number">12</span> paths <span class="hljs-keyword">from</span> d480c4f</code></pre></div><p>这样，<code>work dir</code>和<code>stage</code>中所有的「修改」都会被撤销，恢复成<code>HEAD</code>指向的那个<code>history commit</code>。</p><p>注意，类似之前通过<code>stage</code>恢复<code>work dir</code>的<code>checkout</code>命令，这里撤销的也只是修改，新增的文件不会被撤销。</p><p>当然，只要找到任意一个<code>commit</code>的 HASH 值，<code>checkout</code>命令可就以将文件恢复成任一个<code>history commit</code>中的样子：</p><div class="hljs"><pre><code class="hljs angelscript">$ git checkout <span class="hljs-number">2</span>bdf04a some_test.goUpdated <span class="hljs-number">1</span> path <span class="hljs-keyword">from</span> <span class="hljs-number">2</span>bdf04a# 前文的用法显示 update <span class="hljs-keyword">from</span> index</code></pre></div><p>比如，我改了某个测试文件，结果发现测试跑不过了，所以就把该文件恢复到了它能跑过的那个历史版本……</p><p><strong>风险等级：高风险。</strong></p><p>理由：这个操作会将指定文件在<code>work dir</code>的数据恢复成指定<code>commit</code>的样子，且会删除该文件在<code>stage</code>中的数据，都无法恢复，所以应该慎重使用。</p><h3 id="三、其他技巧"><a href="#三、其他技巧" class="headerlink" title="三、其他技巧"></a>三、其他技巧</h3><p><strong>需求一，合并多个<code>commit</code></strong>。</p><p>比如说我本地从<code>17bd20c</code>到<code>HEAD</code>有多个<code>commit</code>，但我希望把他们合并成一个<code>commit</code>推到远程仓库，这时候就可以使用<code>reset</code>命令：</p><div class="hljs"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git reset <span class="hljs-number">17</span>bd20c<span class="hljs-variable">$ </span>git add .<span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">'balabala'</span></code></pre></div><p>回顾一下刚才说的<code>reset</code>命令的作用，相当于把 HEAD 移到了<code>17bd20c</code>这个<code>commit</code>，而且不会修改<code>work dir</code>中的数据，所以只要<code>add</code>再<code>commit</code>，就相当于把中间的多个<code>commit</code>合并到一个了。</p><p><strong>需求二，由于<code>HEAD</code>指针的回退，导致有的<code>commit</code>在<code>git log</code>命令中无法看到，怎么得到它们的 Hash 值呢</strong>？</p><p>再重复一遍，只要你不乱动本地的<code>.git</code>文件夹，任何修改只要提交到<code>commit history</code>中，都永远不会丢失，看不到某些<code>commit</code>只是因为它们不是我们当前<code>HEAD</code>位置的「历史」提交，我们可以使用如下命令查看操作记录：</p><div class="hljs"><pre><code class="hljs angelscript">$ git <span class="hljs-built_in">ref</span>log</code></pre></div><p>比如<code>reset</code>，<code>checkout</code>等等关键操作都会在这里留下记录，所有<code>commit</code>的 Hash 值都能在这里找到，所以如果你发现有哪个<code>commit</code>突然找不到了，一定都可以在这里找到。</p><p><strong>需求三，怎么解决冲突</strong>？</p><p>记住，Git 虽然高大上，但也不要迷恋，一定要懂得借助先进的工具。</p><p>比较流行的代码编辑器或者 IDE 都会集成方便的可视化 Git 工具，至于解决冲突，可视化的表现方式不是比你在命令行里<code>git diff</code>看半天要清晰明了得多？只需要点点点就行了。</p><p>所以说，只要明白本文讲的这些基本操作，够你用的了，平时能用图形化工具就多用图形化工具，毕竟工具都是为人服务的。</p><p>别忘了看看 <a href="https://www.yossi.top/2020/07/12/刷题学习-GitSQL正则表达式/" target="_blank" rel="noopener">一起刷题学习 Git/SQL/正则表达式</a>。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用指令</title>
    <link href="/2020/07/11/15:43.html"/>
    <url>/2020/07/11/15:43.html</url>
    
    <content type="html"><![CDATA[<p>这篇文章，我把那些命令都分类总结了一下（当然，是参考别人的分类的），这些总结大部分来自于我买的一个 Git 鼠标垫，主要是为了以后自己忘记了方便查找。</p><a id="more"></a><h2 id="一、Git-配置相关"><a href="#一、Git-配置相关" class="headerlink" title="一、Git 配置相关"></a>一、Git 配置相关</h2><p>如果你首次使用 Git，那刚开始首先是需要配置各种身份信息的，这样当你提交相关任务的时候，别人才能知道这个 commit 是谁提交的。</p><h4 id="（1）、Git-最小配置"><a href="#（1）、Git-最小配置" class="headerlink" title="（1）、Git 最小配置"></a>（1）、Git 最小配置</h4><p>1、配置全局账户，也就是该账户对所有的 Git 仓库都有效</p><div class="hljs"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.name <span class="hljs-string">'你的账户名称'</span>git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">'你的 Email'</span></code></pre></div><p>2、配置局部账户，也就是该账户只对当前 Git 仓库有效</p><div class="hljs"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--local user.name <span class="hljs-string">'你的账户名称'</span> git<span class="hljs-built_in"> config </span>--local user.email <span class="hljs-string">'你的 Email'</span></code></pre></div><p>注意，不同点就是一个参数是 global（全局），一个是 local(本地)</p><h4 id="（2）、查看相关配置情况"><a href="#（2）、查看相关配置情况" class="headerlink" title="（2）、查看相关配置情况"></a>（2）、查看相关配置情况</h4><p>配置了之后，显然有时候是需要查看我们当前配置的相关情况的，可以使用如下命令</p><p>1、查看 global 类型的配置情况</p><div class="hljs"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global --list</code></pre></div><p>2、查看某个仓库下的配置情况</p><div class="hljs"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--local --list</code></pre></div><h2 id="二、本地基本操作"><a href="#二、本地基本操作" class="headerlink" title="二、本地基本操作"></a>二、本地基本操作</h2><p>这部分命令有点多，也是使用的最频繁的命令了，待我一一列举出来，建议收藏</p><h4 id="（1）、基本操作"><a href="#（1）、基本操作" class="headerlink" title="（1）、基本操作"></a>（1）、基本操作</h4><p>1、查看变更情况</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span></code></pre></div><p>2、查看当前工作在哪个分支上</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-v</code></pre></div><p>3、切换到指定分支</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> checkout 指定分支的名称</code></pre></div><p>4、把<strong>当前目录及其子目录</strong>下所有变更都加入到<strong>暂存区</strong></p><div class="hljs"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span> . // 注意，<span class="hljs-keyword">add</span> 后面是一个 <span class="hljs-string">'.'</span>；</code></pre></div><p>5、把仓库内<strong>所有</strong>变更都假如到暂存区</p><div class="hljs"><pre><code class="hljs dockerfile">git <span class="hljs-keyword">add</span><span class="bash"> -A</span></code></pre></div><p>6、把指定文件添加到暂存区</p><div class="hljs"><pre><code class="hljs routeros">git <span class="hljs-builtin-name">add</span> 文件1 文件2 <span class="hljs-built_in">..</span>. 文件n</code></pre></div><p>7、创建正式的 commit，也就是把当前的数据提交上去</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">git commit</span></code></pre></div><h4 id="（二）、比较差异"><a href="#（二）、比较差异" class="headerlink" title="（二）、比较差异"></a>（二）、比较差异</h4><p>1、比较某文件工作区和暂存区的差异</p><div class="hljs"><pre><code class="hljs maxima">git <span class="hljs-built_in">diff</span> 某文件</code></pre></div><p>2、比较某文件暂存区和 HEAD 的差异</p><div class="hljs"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">diff </span>--<span class="hljs-keyword">cache </span>某文件</code></pre></div><p>3、比较工作区和暂存区的所有差异</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">git diff</span></code></pre></div><p>4、比较暂存区和 HEAD 的所有差异</p><div class="hljs"><pre><code class="hljs ada">git diff <span class="hljs-comment">--cache</span></code></pre></div><h4 id="（3）、暂存区与工作区之间回滚"><a href="#（3）、暂存区与工作区之间回滚" class="headerlink" title="（3）、暂存区与工作区之间回滚"></a>（3）、暂存区与工作区之间回滚</h4><p>1、把工作区指定文件恢复成和暂存区一样</p><div class="hljs"><pre><code class="hljs angelscript">git checkout 文件<span class="hljs-number">1</span> 文件<span class="hljs-number">2</span> ... 文件n</code></pre></div><p>2、把暂存区指定文件回复和 HEAD 一样</p><div class="hljs"><pre><code class="hljs angelscript">git reset 文件<span class="hljs-number">1</span> 文件<span class="hljs-number">2</span> ... 文件n</code></pre></div><p>3、把暂存区和工作区所有文件恢复成和 HEAD 一样</p><div class="hljs"><pre><code class="hljs pgsql">git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard</span></code></pre></div><p>4、用 difftool 比较任意两个 commit 的差异</p><div class="hljs"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">difftool </span>commit1 commit2</code></pre></div><blockquote><p>注意，从工作区回滚到暂存区则用 checkout ，否则用 reset</p></blockquote><h4 id="（四）、其他"><a href="#（四）、其他" class="headerlink" title="（四）、其他"></a>（四）、其他</h4><p>查看哪些文件没有被 Git 管控</p><div class="hljs"><pre><code class="hljs livecodeserver">git ls-<span class="hljs-built_in">files</span> <span class="hljs-comment">--others</span></code></pre></div><h2 id="三、加塞临时任务处理"><a href="#三、加塞临时任务处理" class="headerlink" title="三、加塞临时任务处理"></a>三、加塞临时任务处理</h2><p>1、把未处理完的变更先保存到 stash 中</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">git stash</span></code></pre></div><p>2、临时任务处理完后继续之前的工作</p><div class="hljs"><pre><code class="hljs maxima">git stash <span class="hljs-built_in">pop</span> // <span class="hljs-built_in">pop</span> 相当于栈的出栈和入栈一样，把之前的任务弹出来或者git stash <span class="hljs-built_in">apply</span> // 和 <span class="hljs-built_in">pop</span> 不同的是， <span class="hljs-built_in">apply</span> 相当于从栈顶把任务取出来，但是不过从栈中把任务移除</code></pre></div><p>3、查看所有的 stash</p><div class="hljs"><pre><code class="hljs applescript">git stash <span class="hljs-built_in">list</span></code></pre></div><p>4、取回某次 stash 的变更</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> stash <span class="hljs-keyword">pop </span>stash <span class="hljs-comment">@&#123;数字n&#125;</span></code></pre></div><h2 id="四、修改个人分支历史"><a href="#四、修改个人分支历史" class="headerlink" title="四、修改个人分支历史"></a>四、修改个人分支历史</h2><p>我们的仓库的内容每次变更执行 commit 的时候，都会生成一个新的 commit，不过有时候，我们不想产生新的 commit，而是想要通过修改之前的 commit 来变更仓库的内容，那么就可以使用如下命令了</p><p>1、修改最后一次 commit</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1</span>、在工作区中修改文件<span class="hljs-number">2</span>、git add<span class="hljs-number">3</span>、git commit --amend</code></pre></div><p>2|、修改中间的 commit(假设代号为 X)</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> git rebase -i X前面的一个 commit 的 id<span class="hljs-number">2.</span> 在工作区修改文件<span class="hljs-number">3.</span> git add<span class="hljs-number">4.</span> git rebase --contiue</code></pre></div><h2 id="五、查看变更日志等"><a href="#五、查看变更日志等" class="headerlink" title="五、查看变更日志等"></a>五、查看变更日志等</h2><p>1、当前分支各个 commit 用一行显示</p><div class="hljs"><pre><code class="hljs applescript">git <span class="hljs-built_in">log</span> <span class="hljs-comment">--online</span></code></pre></div><p>2、显示最近的 n 个 commit</p><div class="hljs"><pre><code class="hljs excel">git <span class="hljs-built_in">log</span> -<span class="hljs-built_in">n</span></code></pre></div><p>3、用图示显示所有的分支历史</p><div class="hljs"><pre><code class="hljs brainfuck"><span class="hljs-comment">git</span> <span class="hljs-comment">log</span> --<span class="hljs-comment">online</span> --<span class="hljs-comment">graph</span> --<span class="hljs-comment">all</span></code></pre></div><p>4、查看涉及到某文件变更的所有 commit</p><div class="hljs"><pre><code class="hljs 1c">git <span class="hljs-built_in">log</span> 某文件</code></pre></div><p>5、某文件各行最后修改对应的 commit 以及作者</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">blame </span>某文件</code></pre></div><h2 id="六、分支与标签"><a href="#六、分支与标签" class="headerlink" title="六、分支与标签"></a>六、分支与标签</h2><h4 id="1、创建新分支"><a href="#1、创建新分支" class="headerlink" title="1、创建新分支"></a>1、创建新分支</h4><p>基于当前分支创建新分支</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>新分支</code></pre></div><p>基于指定分支创建新分支</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>新分支 已有分支</code></pre></div><p>基于某个 commit 创建分支</p><div class="hljs"><pre><code class="hljs sql">git branch 新分支 某个 <span class="hljs-keyword">commit</span> 的<span class="hljs-keyword">id</span></code></pre></div><p>创建分支并且切换到该分支</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> chechout -<span class="hljs-keyword">b </span>新分支</code></pre></div><h4 id="2、列出分支"><a href="#2、列出分支" class="headerlink" title="2、列出分支"></a>2、列出分支</h4><p>列出本地分支</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-v</code></pre></div><p>列出本地和远端分支</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-av</code></pre></div><p>列出远端所有分支</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-rv</code></pre></div><p>列出名称符号某样式的远端分支</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> branch -rv -l <span class="hljs-string">'某样式'</span></code></pre></div><h4 id="3、删除分支"><a href="#3、删除分支" class="headerlink" title="3、删除分支"></a>3、删除分支</h4><p>安全删除本地某分支</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-d 要删除的分支</code></pre></div><p>强行删除本地分支</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-D 要删除的分支</code></pre></div><p>删除已合并到 master 分支的所有本地分支</p><div class="hljs"><pre><code class="hljs crmsh">git branch --merged <span class="hljs-keyword">master</span> <span class="hljs-title">| grep</span> -v '^\*\| <span class="hljs-literal">master</span>' | xargs -n <span class="hljs-number">1</span> git branch -d</code></pre></div><p>删除远端 origin 已不存在的所有本地分支</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">git remote prune origin</span></code></pre></div><h4 id="4、打标签"><a href="#4、打标签" class="headerlink" title="4、打标签"></a>4、打标签</h4><p>从 commit 打上标签</p><div class="hljs"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">标签名 commit</span> 的id</code></pre></div><h2 id="七、两分支之间的集成"><a href="#七、两分支之间的集成" class="headerlink" title="七、两分支之间的集成"></a>七、两分支之间的集成</h2><p>1、把 A 分支合入到当前分支，且为 merge 创建 commit</p><div class="hljs"><pre><code class="hljs cos">git <span class="hljs-keyword">merge</span> A分支</code></pre></div><p>2、把 A 分支合入到 B 分支，且为 Merge 创建 commit</p><div class="hljs"><pre><code class="hljs cos">git <span class="hljs-keyword">merge</span> A分支 B分支</code></pre></div><p>3、把当前分支基于B分支做 rebase，以便把B分支合入到当前分支</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> rebase B分支</code></pre></div><p>4、把A分支基于B分支做rebase，以便把B分支合入到A分支</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> rebase <span class="hljs-keyword">B分支 </span>A分支</code></pre></div><p>5、用 mergetool 解决冲突</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">git mergetool</span></code></pre></div><h2 id="八、和远端交互"><a href="#八、和远端交互" class="headerlink" title="八、和远端交互"></a>八、和远端交互</h2><p>1、列出所有 remote</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">git remote -v</span></code></pre></div><p>2、增加 remote</p><div class="hljs"><pre><code class="hljs dockerfile">git remote <span class="hljs-keyword">add</span><span class="bash"> url地址</span></code></pre></div><p>3、删除 remote</p><div class="hljs"><pre><code class="hljs routeros">git remote <span class="hljs-builtin-name">remove</span> remote的名称</code></pre></div><p>4、改变 remote 的name</p><div class="hljs"><pre><code class="hljs coq">git remote <span class="hljs-built_in">rename</span> 旧名称 新名称</code></pre></div><p>5、把远端所有分支和标签的变更都拉到本地</p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">git fetch remote</span></code></pre></div><p>6、把远端分支的变更拉倒本地，且 merge 到本地分支</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> pull remote名称 分支名</code></pre></div><p>关于 pull 和 fetch 的区别不懂可以看这篇文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247486636&idx=2&sn=b3d94e89b4bf2e7dba8b995dc694ccd8&scene=21#wechat_redirect" target="_blank" rel="noopener">从0学习Git：详解git pull和git fetch的区别</a></p><p>7、把本地分支 push 到远端</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">push </span>remote名称 分支名</code></pre></div><p>8、删除远端分支</p><div class="hljs"><pre><code class="hljs gauss">git <span class="hljs-keyword">push</span> remote --<span class="hljs-keyword">delete</span> 远端分支名或者git <span class="hljs-keyword">push</span> remote:远端分支名</code></pre></div><p>9、向远端提交指定标签</p><div class="hljs"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">push </span>remote 标签名</code></pre></div><p>10、向远端提交所有标签</p><div class="hljs"><pre><code class="hljs ada">git push remote <span class="hljs-comment">--tags</span></code></pre></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果把这些命令掌握了，那么 git 就顺手拈来了，不过很多命令是比较容易忘的，所有还是比较需要一份 git 手册，以后用到的时候多查几次，多用几次命令，相信就能够记住了。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【干货】40 张图解的TCP三次握手和四次挥手面试题</title>
    <link href="/2020/07/10/12:28.html"/>
    <url>/2020/07/10/12:28.html</url>
    
    <content type="html"><![CDATA[<div class="note note-success">            <p> 以下文章来源于小林coding ，作者小林coding</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247485167&idx=2&sn=19facbf79be561aee497e36d61d4c3a3&chksm=9bd7f8e7aca071f1d0330bf4aa8850e6ac050da7aad2af5a1b609e6a9c330b5b9c710ca6ddde&scene=27&key=f543c887ce3fc2eeec0ff22f503eb7e79ab7672d5d907dd2688ef9aec933372dbc4e64a8c442aaff787757c62db7f03ba2a652f3fea132f37128ec504966fcf0974440b2af0306511927583d38dcd9df&ascene=3&uin=MTcxNzk5MDg4Mw%3D%3D&devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.15.3+build(19D76)&version=12040110&nettype=WIFI&lang=zh_CN&fontScale=100&exportkey=A%2FA5p0G8KBtlGII2F6888CU%3D&pass_ticket=o9wrIFUXhdldGPPyrkbhg2lCZsYM6JOjasA4oFxnBnEbdeXk1E2Dz3X%2B7H1rrXYa&winzoom=1.000000#" target="_blank" rel="noopener"><strong>小林coding</strong>用简洁的方式，分享编程小知识。</a></p><p>转载自公众号：小林coding</p><p>本文作者：小林coding</p>          </div> <hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不管面试 Java 、C/C++、Python 等开发岗位， <code>TCP</code> 的知识点可以说是的必问的了。</p><p><strong>任 TCP 虐我千百遍，我仍待 TCP 如初恋。</strong></p><p>遥想小林当年校招时常因 <code>TCP</code> 面试题被刷，真是又爱又狠….</p><p>过去不会没关系，今天就让我们来消除这份恐惧，微笑着勇敢的面对它吧！</p><p>所以小林整理了关于 <strong>TCP 三次握手和四次挥手的面试题型</strong>，跟大家一起探讨探讨。</p><ol><li>TCP 基本认识</li></ol><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152851.png" srcset="/img/loading.gif" alt="img"></p><ol><li>TCP 连接建立</li></ol><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152857.png" srcset="/img/loading.gif" alt="img"></p><ol><li>TCP 连接断开</li></ol><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152902.png" srcset="/img/loading.gif" alt="img"></p><ol><li>Socket 编程</li></ol><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152906.png" srcset="/img/loading.gif" alt="img"></p><blockquote><p>PS：本次文章不涉及 TCP 流量控制、拥塞控制、可靠性传输等方面知识，这些留在下篇哈！</p></blockquote><hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="01-TCP-基本认识"><a href="#01-TCP-基本认识" class="headerlink" title="01 TCP 基本认识"></a>01 TCP 基本认识</h3><blockquote><p>瞧瞧 TCP 头格式</p></blockquote><p>我们先来看看 TCP 头的格式，标注颜色的表示与本文关联比较大的字段，其他字段不做详细阐述。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152927.png" srcset="/img/loading.gif" alt="TCP 头格式">TCP 头格式</p><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决不丢包的问题。</strong></p><p><strong>控制位：</strong></p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYC</em>：该位为 <code>1</code> 时，表示希望建立连，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位置为 1 的 TCP 段。</li></ul><blockquote><p>为什么需要 TCP 协议？TCP 工作在哪一层？</p></blockquote><p><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152928.png" srcset="/img/loading.gif" alt="OSI 参考模型与 TCP/IP 的关系">OSI 参考模型与 TCP/IP 的关系</p><p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><blockquote><p>什么是 TCP ？</p></blockquote><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152929.png" srcset="/img/loading.gif" alt="img"></p><ul><li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li><li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li><li><strong>字节流</strong>：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</li></ul><blockquote><p>什么是 TCP 连接？</p></blockquote><p>我们来看看 RFC 793 是如何定义「连接」的：</p><p><em>Connections:</em> </p><p><em>The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream.</em>  </p><p><em>The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</em></p><p>简单来说就是，<strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。</strong></p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152930.png" srcset="/img/loading.gif" alt="img"></p><p>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务器端达成上述三个信息的共识。</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制</li></ul><blockquote><p>如何唯一确定一个 TCP 连接呢？</p></blockquote><p>TCP 四元组可以唯一的确定一个连接，四元组包括如下：</p><ul><li>源地址</li><li>源端口</li><li>目的地址</li><li>目的端口</li></ul><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152931.png" srcset="/img/loading.gif" alt="TCP 四元组">TCP 四元组</p><p>源地址和目的地址的字段（32位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p><p>源端口和目的端口的字段（16位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p><blockquote><p>有一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</p></blockquote><p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。</p><p>因此，客户端 IP 和 端口是可变的，其理论值计算公式如下:</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152932.png" srcset="/img/loading.gif" alt="img"></p><p>对 IPv4，客户端的 IP 数最多为 <code>2</code> 的 <code>32</code> 次方，客户端的端口数最多为 <code>2</code> 的 <code>16</code>次方，也就是服务端单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方。</p><p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。</p><ul><li>首先主要是<strong>文件描述符限制</strong>，Socket 都是文件，所以首先要通过 <code>ulimit</code> 配置文件描述符的数目；</li><li>另一个是<strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统是有限的。</li></ul><blockquote><p>UDP 和 TCP 有什么区别呢？分别的应用场景是？</p></blockquote><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。</p><p>UDP 协议真的非常简，头部只有 <code>8</code> 个字节（ 64 位），UDP 的头部格式如下：</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152933.png" srcset="/img/loading.gif" alt="UDP 头部格式">UDP 头部格式</p><ul><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。</li></ul><p><strong>TCP 和 UDP 区别：</strong></p><p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。</li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><strong>TCP 和 UDP 应用场景：</strong></p><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输</li><li><code>HTTP</code> / <code>HTTPS</code></li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等</li><li>视频、音频等多媒体通信</li><li>广播通信</li></ul><blockquote><p>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</p></blockquote><p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p><blockquote><p>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</p></blockquote><p>先说说 TCP 是如何计算负载数据长度：</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152934.png" srcset="/img/loading.gif" alt="img"></p><p>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p><p>大家这时就奇怪了问：“ UDP 也是基于 IP 层的呀，那 UDP 的数据长度也可以通过这个公式计算呀？为何还要有「包长度」呢？”</p><p>这么一问，确实感觉 UDP 「包长度」是冗余的。</p><p><strong>因为为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code>字节的整数倍。</strong></p><p>如果去掉 UDP 「包长度」字段，那 UDP 首部长度就不是 <code>4</code> 字节的整数倍了，所以小林觉得这可能是为了补全 UDP 首部长度是 <code>4</code> 字节的整数倍，才补充了「包长度」字段。</p><h3 id="02-TCP-连接建立"><a href="#02-TCP-连接建立" class="headerlink" title="02 TCP 连接建立"></a>02 TCP 连接建立</h3><blockquote><p>TCP 三次握手过程和状态变迁</p></blockquote><p>TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而<strong>建立连接是通过三次握手而进行的。</strong></p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152935.png" srcset="/img/loading.gif" alt="TCP 三次握手">TCP 三次握手</p><ul><li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li></ul><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152936.png" srcset="/img/loading.gif" alt="第一个报文—— SYN 报文">第一个报文—— SYN 报文</p><ul><li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li></ul><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152937.png" srcset="/img/loading.gif" alt="第二个报文 —— SYN + ACK 报文">第二个报文 —— SYN + ACK 报文</p><ul><li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li></ul><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152938.png" srcset="/img/loading.gif" alt="第三个报文 —— ACK 报文">第三个报文 —— ACK 报文</p><ul><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code>，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li><li>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li></ul><p>从上面的过程可以发现<strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong>，这也是面试常问的题。</p><p>一旦完成三次握手，双方都处于 <code>ESTABLISHED</code> 状态，此致连接就已建立完成，客户端和服务端就可以相互发送数据了。</p><blockquote><p>如何在 Linux 系统中查看 TCP 状态？</p></blockquote><p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152939.png" srcset="/img/loading.gif" alt="TCP 连接状态查看">TCP 连接状态查看</p><blockquote><p>为什么是三次握手？不是两次、四次？</p></blockquote><p>相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”</p><p>这回答是没问题，但这回答是片面的，并没有说出主要的原因。</p><p>在前面我们知道了什么是 <strong>TCP 连接</strong>：</p><ul><li>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括<strong>Socket、序列号和窗口大小</strong>称为连接。</li></ul><p>所以，重要的是<strong>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。</strong></p><p>接下来以三个方面分析三次握手的原因：</p><ul><li>三次握手才可以阻止历史重复连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><p><em>原因一：避免历史连接</em></p><p>我们来看看 RFC 793 指出的 TCP 连接使用三次握手的<strong>首要原因</strong>：</p><p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p><p>简单来说，三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p><p>网络环境是错综复杂的，往往并不是如我们期望的一样，先发送的数据包，就先到达目标主机，反而它很骚，可能会由于网络拥堵等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下 TCP 三次握手是如何避免的呢？</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152940.png" srcset="/img/loading.gif" alt="三次握手避免历史连接">三次握手避免历史连接</p><p>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵等情况下：</p><ul><li>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；</li><li>那么此时服务端就会回一个 <code>SYN + ACK</code> 报文给客户端；</li><li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 <code>RST</code> 报文给服务端，表示中止这一次连接。</li></ul><p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</p><ul><li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 <code>RST</code> 报文，以此中止历史连接；</li><li>如果不是历史连接，则第三次发送的报文是 <code>ACK</code> 报文，通信双方就会成功建立连接；</li></ul><p>所以， TCP 使用三次握手建立连接的最主要原因是<strong>防止历史连接初始化了连接。</strong></p><p><em>原因二：同步双方初始序列号</em></p><p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p><ul><li>接收方可以去除重复的数据；</li><li>接收方可以根据数据包的序列号按序接收；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</li></ul><p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152941.png" srcset="/img/loading.gif" alt="四次握手与三次握手">四次握手与三次握手</p><p>四次握手其实也能够可靠的同步双方的初始化序号，但由于<strong>第二步和第三步可以优化成一步</strong>，所以就成了「三次握手」。</p><p>而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p><p><em>原因三：避免资源浪费</em></p><p>如果只有「两次握手」，当客户端的 <code>SYN</code> 请求连接在网络中阻塞，客户端没有接收到 <code>ACK</code> 报文，就会重新发送 <code>SYN</code> ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 <code>ACK</code> 确认信号，所以每收到一个 <code>SYN</code> 就只能先主动建立一个连接，这会造成什么情况呢？</p><p>如果客户端的 <code>SYN</code> 阻塞了，重复发送多次 <code>SYN</code> 报文，那么服务器在收到请求后就会<strong>建立多个冗余的无效链接，造成不必要的资源浪费。</strong></p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152942.jpeg" srcset="/img/loading.gif" alt="两次握手会造成资源浪费">两次握手会造成资源浪费</p><p>即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p><p><em>小结</em></p><p>TCP 建立连接时，通过三次握手<strong>能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号</strong>。序列号能够保证数据包不重复、不丢弃和按序传输。</p><p>不使用「两次握手」和「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><blockquote><p>为什么客户端和服务端的初始序列号 ISN 是不相同的？</p></blockquote><p>因为网络中的报文<strong>会延迟、会复制重发、也有可能丢失</strong>，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。</p><blockquote><p>初始序列号 ISN 是如何随机产生的？</p></blockquote><p>起始 <code>ISN</code> 是基于时钟的，每 4 毫秒 + 1，转一圈要 4.55 个小时。</p><p>RFC1948 中提出了一个较好的初始化序列号 ISN 随机生成算法。</p><p><em>ISN = M + F (localhost, localport, remotehost, remoteport)</em></p><ul><li><code>M</code> 是一个计时器，这个计时器每隔 4 毫秒加 1。</li><li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li></ul><blockquote><p>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？</p></blockquote><p>我们先来认识下 MTU 和 MSS</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152943.png" srcset="/img/loading.gif" alt="MTU 与 MSS">MTU 与 MSS</p><ul><li><code>MTU</code>：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节；</li><li><code>MSS</code>：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li></ul><p>如果TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？</p><p>当 IP 层有一个超过 <code>MTU</code> 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，在交给上一层 TCP 传输层。</p><p>这看起来井然有序，但这存在隐患的，<strong>那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传</strong>。</p><p>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</p><p>当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。</p><p>因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</p><p>所以，为了达到最佳的传输效能 TCP 协议在<strong>建立连接的时候通常要协商双方的 MSS 值</strong>，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152944.png" srcset="/img/loading.gif" alt="握手阶段协商 MSS">握手阶段协商 MSS</p><p>经过 TCP 层分片后，如果一个 TCP 分片丢失后，<strong>进行重发时也是以 MSS 为单位</strong>，而不用重传所有的分片，大大增加了重传的效率。</p><blockquote><p>什么是 SYN 攻击？如何避免 SYN 攻击？</p></blockquote><p><em>SYN 攻击</em></p><p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的 SYN 接收队列（未连接队列）</strong>，使得服务器不能为正常用户服务。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152945.png" srcset="/img/loading.gif" alt="SYN 攻击">SYN 攻击</p><p><em>避免 SYN 攻击方式一</em></p><p>其中一种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。</p><ul><li>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">net</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.netdev_max_backlog</span></code></pre></div><ul><li>SYN_RCVD 状态连接的最大个数：</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">net</span><span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.tcp_max_syn_backlog</span></code></pre></div><ul><li>超出处理能时，对新的 SYN 直接回 RST，丢弃连接：</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">net</span><span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.tcp_abort_on_overflow</span></code></pre></div><p><em>避免 SYN 攻击方式二</em></p><p>我们先来看下Linux 内核的 <code>SYN</code> （未完成连接建立）队列与 <code>Accpet</code> （已完成连接建立）队列是如何工作的？</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152946.png" srcset="/img/loading.gif" alt="正常流程">正常流程</p><p>正常流程：</p><ul><li>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</li><li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li><li>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</li><li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接。</li></ul><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152947.png" srcset="/img/loading.gif" alt="应用程序过慢">应用程序过慢</p><p>应用程序过慢：</p><ul><li>如果应用程序过慢时，就会导致「 Accept 队列」被占满。</li></ul><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152948.png" srcset="/img/loading.gif" alt="受到 SVN 攻击">受到 SYN 攻击</p><p>受到 SYN 攻击：</p><ul><li>如果不断受到 SYN 攻击，就会导致「 SYN 队列」被占满。</li></ul><p><code>tcp_syncookies</code> 的方式可以应对 SYN 攻击的方法：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">net.ipv4.tcp_syncookies</span> = <span class="hljs-number">1</span></code></pre></div><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152949.png" srcset="/img/loading.gif" alt="tcp_syncookies 应对 SYN 攻击">tcp_syncookies 应对 SYN 攻击</p><ul><li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</li><li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「序列号」返回客户端，</li><li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。</li><li>最后应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接。</li></ul><hr><h3 id="03-TCP-连接断开"><a href="#03-TCP-连接断开" class="headerlink" title="03 TCP 连接断开"></a>03 TCP 连接断开</h3><blockquote><p>TCP 四次挥手过程和状态变迁</p></blockquote><p>天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过<strong>四次挥手</strong>方式。</p><p>双方都可以主动断开连接，断开连接后主机中的「资源」将被释放。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152950.png" srcset="/img/loading.gif" alt="客户端主动关闭连接 —— TCP 四次挥手">客户端主动关闭连接 —— TCP 四次挥手</p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ul><p>你可以看到，每个方向都需要<strong>一个 FIN 和一个 ACK</strong>，因此通常被称为<strong>四次挥手</strong>。</p><p>这里一点需要注意是：<strong>主动关闭连接的，才有 TIME_WAIT 状态。</strong></p><blockquote><p>为什么挥手需要四次？</p></blockquote><p>再来回顾下四次挥手双方发 <code>FIN</code> 包的过程，就能理解为什么需要四次了。</p><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务器收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code>和 <code>FIN</code> 一般都会分开发送，从而比三次握手导致多了一次。</p><blockquote><p>为什么 TIME_WAIT 等待的时间是 2MSL？</p></blockquote><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p><p>MSL 与 TTL 的区别：MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p><p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p><p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 Fin 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p><p><code>2MSL</code> 的时间是从<strong>客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p><p>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code> 秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。<strong>Linux 系统停留在 TIME_WAIT 的时间为固定的 60 秒</strong>。</p><p>其定义在 Linux 内核代码里的名称为 TCP_TIMEWAIT_LEN：</p><div class="hljs"><pre><code class="hljs pf"><span class="hljs-comment">#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT </span>                                    <span class="hljs-keyword">state</span>, about <span class="hljs-number">60</span> seconds  */</code></pre></div><p>如果要修改 TIME_WAIT 的时间长度，只能修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值，并重新编译 Linux 内核。</p><blockquote><p>为什么需要 TIME_WAIT 状态？</p></blockquote><p>主动发起关闭连接的一方，才会有 <code>TIME-WAIT</code> 状态。</p><p>需要 TIME-WAIT 状态，主要是两个原因：</p><ul><li>防止具有相同「四元组」的「旧」数据包被收到；</li><li>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</li></ul><p><em>原因一：防止旧连接的数据包</em></p><p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152825.png" srcset="/img/loading.gif" alt="接收到历史数据的异常">接收到历史数据的异常</p><ul><li>如上图黄色框框服务端在关闭连接之前发送的 <code>SEQ = 301</code> 报文，被网络延迟了。</li><li>这时有相同端口的 TCP 连接被复用后，被延迟的 <code>SEQ = 301</code> 抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。</li></ul><p>所以，TCP 就设计出了这么一个机制，经过 <code>2MSL</code> 这个时间，<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</strong></p><p><em>原因二：保证连接正确关闭</em></p><p>在 RFC 793 指出 TIME-WAIT 另一个重要的作用是：</p><p><em>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</em></p><p>也就是说，TIME-WAIT 作用是<strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</strong></p><p>假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152951.png" srcset="/img/loading.gif" alt="没有确保正常断开的异常">没有确保正常断开的异常</p><ul><li>如上图红色框框客户端四次挥手的最后一个 <code>ACK</code> 报文如果在网络中被丢失了，此时如果客户端 <code>TIME-WAIT</code> 过短或没有，则就直接进入了 <code>CLOSE</code> 状态了，那么服务端则会一直处在 <code>LASE-ACK</code> 状态。</li><li>当客户端发起建立连接的 <code>SYN</code> 请求报文后，服务端会发送 <code>RST</code> 报文给客户端，连接建立的过程就会被终止。</li></ul><p>如果 TIME-WAIT 等待足够长的情况就会遇到两种情况：</p><ul><li>服务端正常收到四次挥手的最后一个 <code>ACK</code> 报文，则服务端正常关闭连接。</li><li>服务端没有收到四次挥手的最后一个 <code>ACK</code> 报文时，则会重发 <code>FIN</code> 关闭连接报文并等待新的 <code>ACK</code> 报文。</li></ul><p>所以客户端在 <code>TIME-WAIT</code> 状态等待 <code>2MSL</code> 时间后，就可以<strong>保证双方的连接都可以正常的关闭。</strong></p><blockquote><p>TIME_WAIT 过多有什么危害？</p></blockquote><p>如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器方主动发起的断开请求。</p><p>过多的 TIME-WAIT 状态主要的危害有两种：</p><ul><li>第一是内存资源占用；</li><li>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；</li></ul><p>第二个危害是会造成严重的后果的，要知道，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过如下参数设置指定</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">net</span><span class="hljs-selector-class">.ipv4</span><span class="hljs-selector-class">.ip_local_port_range</span></code></pre></div><p><strong>如果服务端 TIME_WAIT 状态过多，占满了所有端口资源，则会导致无法创建新连接。</strong></p><blockquote><p>如何优化 TIME_WAIT？</p></blockquote><p>这里给出优化 TIME-WAIT 的几个方式，都是有利有弊：</p><ul><li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li><li>net.ipv4.tcp_max_tw_buckets</li><li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li></ul><p><em>方式一：net.ipv4.tcp_tw_reuse 和 tcp_timestamps</em></p><p>如下的 Linux 内核参数开启后，则可以<strong>复用处于 TIME_WAIT 的 socket 为新的连接所用</strong>。</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">net.ipv4.tcp_tw_reuse</span> = <span class="hljs-number">1</span></code></pre></div><p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p><div class="hljs"><pre><code class="hljs angelscript">net.ipv4.tcp_timestamps=<span class="hljs-number">1</span>（默认即为 <span class="hljs-number">1</span>）</code></pre></div><p>这个时间戳的字段是在 TCP 头部的「选项」里，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。</p><p>由于引入了时间戳，我们在前面提到的 <code>2MSL</code> 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p><p>温馨提醒：<code>net.ipv4.tcp_tw_reuse</code>要慎用，因为使用了它就必然要打开时间戳的支持 <code>net.ipv4.tcp_timestamps</code>，<strong>当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉</strong>。小林在工作中就遇到过。。。排查了非常的久</p><p><em>方式二：net.ipv4.tcp_max_tw_buckets</em></p><p>这个值默认为 18000，当系统中处于 TIME_WAIT 的连接<strong>一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置。</strong></p><p>这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。</p><p><em>方式三：程序中使用 SO_LINGER</em></p><p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">linger</span> <span class="hljs-title">so_linger</span>;</span>so_linger.l_onoff = <span class="hljs-number">1</span>;so_linger.l_linger = <span class="hljs-number">0</span>;setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,<span class="hljs-keyword">sizeof</span>(so_linger));</code></pre></div><p>如果<code>l_onoff</code>为非 0， 且<code>l_linger</code>值为 0，那么调用<code>close</code>后，会立该发送一个<code>RST</code>标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了<code>TIME_WAIT</code>状态，直接关闭。</p><p>但这为跨越<code>TIME_WAIT</code>状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p><blockquote><p>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p></blockquote><p>TCP 有一个机制是<strong>保活机制</strong>。这个机制的原理是这样的：</p><p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p><p>在 Linux 内核可以有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都为默认值：</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">net.ipv4.tcp_keepalive_time</span>=<span class="hljs-number">7200</span><span class="hljs-attr">net.ipv4.tcp_keepalive_intvl</span>=<span class="hljs-number">75</span>  <span class="hljs-attr">net.ipv4.tcp_keepalive_probes</span>=<span class="hljs-number">9</span></code></pre></div><ul><li>tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li><li>tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；</li><li>tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li></ul><p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152952.png" srcset="/img/loading.gif" alt="img"></p><p>这个时间是有点长的，我们也可以根据实际的需求，对以上的保活相关的参数进行设置。</p><p>如果开启了 TCP 保活，需要考虑以下几种情况：</p><p>第一种，对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</p><p>第二种，对端程序崩溃并重启。当 TCP 保活的探测报文发送给对端后，对端是可以响应的，但由于没有该连接的有效信息，<strong>会产生一个 RST 报文</strong>，这样很快就会发现 TCP 连接已经被重置。</p><p>第三种，是对端程序崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</p><hr><h3 id="03-Socket-编程"><a href="#03-Socket-编程" class="headerlink" title="03 Socket 编程"></a>03 Socket 编程</h3><blockquote><p>针对 TCP 应该如何 Socket 编程？</p></blockquote><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200714152953.png" srcset="/img/loading.gif" alt="基于 TCP 协议的客户端和服务器工作">基于 TCP 协议的客户端和服务器工作</p><ul><li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li><li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li><li>服务端调用 <code>listen</code>，进行监听；</li><li>服务端调用 <code>accept</code>，等待客户端连接；</li><li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li><li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li><li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li><li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li></ul><p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p><p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><blockquote><p>listen 时候参数 backlog 的意义？</p></blockquote><p>Linux内核中会维护两个队列：</p><ul><li>未完成连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于 SYN_RCVD 状态；</li><li>已完成连接队列（Accpet 队列）：已完成 TCP 三次握手过程，处于 ESTABLISHED 状态；</li></ul><p><img src="/child/2020/07/10/12:28/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" srcset="/img/loading.gif" alt="SYN 队列 与 Accpet 队列">SYN 队列 与 Accpet 队列</p><div class="hljs"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> <span class="hljs-keyword">listen</span> (<span class="hljs-keyword">int</span> socketfd, <span class="hljs-keyword">int</span> backlog)</code></pre></div><ul><li>参数一 socketfd 为 socketfd 文件描述符</li><li>参数二 backlog，这参数在历史有一定的变化</li></ul><p>在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。</p><p>在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，<strong>所以现在通常认为 backlog 是 accept 队列。</strong></p><blockquote><p>accept 发送在三次握手的哪一步？</p></blockquote><p>我们先看看客户端连接服务端时，发送了什么？</p><p><img src="/child/2020/07/10/12:28/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" srcset="/img/loading.gif" alt="客户端连接服务端">客户端连接服务端</p><ul><li>客户端的协议栈向服务器端发送了 SYN 包，并告诉服务器端当前发送序列号 client_isn，客户端进入 SYNC_SENT 状态；</li><li>服务器端的协议栈收到这个包之后，和客户端进行 ACK 应答，应答的值为 client_isn+1，表示对 SYN 包 client_isn 的确认，同时服务器也发送一个 SYN 包，告诉客户端当前我的发送序列号为 server_isn，服务器端进入 SYNC_RCVD 状态；</li><li>客户端协议栈收到 ACK 之后，使得应用程序从 <code>connect</code> 调用返回，表示客户端到服务器端的单向连接建立成功，客户端的状态为 ESTABLISHED，同时客户端协议栈也会对服务器端的 SYN 包进行应答，应答数据为 server_isn+1；</li><li>应答包到达服务器端后，服务器端协议栈使得 <code>accept</code> 阻塞调用返回，这个时候服务器端到客户端的单向连接也建立成功，服务器端也进入 ESTABLISHED 状态。</li></ul><p>从上面的描述过程，我们可以得知<strong>客户端 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后。</strong></p><blockquote><p>客户端调用 close 了，连接是断开的流程是什么？</p></blockquote><p>我们看看客户端主动调用了 <code>close</code>，会发生什么？</p><p><img src="/child/2020/07/10/12:28/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" srcset="/img/loading.gif" alt="客户端调用 close 过程">客户端调用 close 过程</p><ul><li>客户端调用 <code>close</code>，表明客户端没有数据需要发送了，则此时会向服务端发送 FIN 报文，进入 FIN_WAIT_1 状态；</li><li>服务端接收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符 <code>EOF</code> 到接收缓冲区中，应用程序可以通过 <code>read</code> 调用来感知这个 FIN 包。这个 <code>EOF</code> 会被<strong>放在已排队等候的其他已接收的数据之后</strong>，这就意味着服务端需要处理这种异常情况，因为 EOF 表示在该连接上再无额外数据到达。此时，服务端进入 CLOSE_WAIT 状态；</li><li>接着，当处理完数据后，自然就会读到 <code>EOF</code>，于是也调用 <code>close</code> 关闭它的套接字，这会使得会发出一个 FIN 包，之后处于 LAST_ACK 状态；</li><li>客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；</li><li>服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；</li><li>客户端进过 <code>2MSL</code> 时间之后，也进入 CLOSED 状态；</li></ul><hr><h6 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h6><p>[1] 趣谈网络协议专栏.刘超.极客时间.</p><p>[2] 网络编程实战专栏.盛延敏.极客时间.</p><p>[3] 计算机网络-自顶向下方法.陈鸣 译.机械工业出版社</p><p>[4] TCP/IP详解 卷1：协议.范建华 译.机械工业出版社</p><p>[5] 图解TCP/IP.竹下隆史.人民邮电出版社</p><p>[6] <a href="https://www.rfc-editor.org/rfc/rfc793.html" target="_blank" rel="noopener">https://www.rfc-editor.org/rfc/rfc793.html</a></p><p>[7] <a href="https://draveness.me/whys-the-design-tcp-three-way-handshake" target="_blank" rel="noopener">https://draveness.me/whys-the-design-tcp-three-way-handshake</a></p><p>[9] <a href="https://draveness.me/whys-the-design-tcp-time-wait" target="_blank" rel="noopener">https://draveness.me/whys-the-design-tcp-time-wait</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的引用与指针的区别</title>
    <link href="/2020/07/03/09:24.html"/>
    <url>/2020/07/03/09:24.html</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>引用(&amp;)是对某个<strong>变量</strong>取一个别名，对引用对操作和直接操作<strong>变量</strong>效果一样；</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-keyword">int</span> a;   <span class="hljs-keyword">int</span> &amp;ra = a;    ra = <span class="hljs-number">1</span>;   <span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;ra&lt;&lt;<span class="hljs-built_in">endl</span>;   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>结果：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-number">1</span></code></pre></div><p>指针(*)是对某个<strong>变量</strong>的地址变量，对地址内容进行操作和直接操作<strong>变量</strong>效果一样；</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> a;    <span class="hljs-keyword">int</span>* p = &amp;a;    *p = <span class="hljs-number">1</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>结果：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-number">1</span></code></pre></div><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>(0) <strong>声明一个引用，不是定义了一个新变量，只是一个别名，所以它本身不是一种数据类型，不会占用内存，但是指针属于指针变量，会占用内存，这就是引用的优点。使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效 率和所占空间都好。使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</strong><br>(1) &amp;在此不是求地址运算符，而是引用标识符；<br>(2) 声明引用时，必须同时对其初始化；<br>(3) 使用引用后，相当于变量内存上有两个变量名，<code>ra=1</code>等价于<code>a=1</code>而使用指针是指针变量指向变量地址<code>*p=1</code>等价于<code>a=1</code>；  </p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200703104540.png" srcset="/img/loading.gif" alt="image-20200703104539112"><br>(4) 不能建立数组的引用，因为数组是由若干个元素所组成的集合，无法创建一个数组的别名；  </p><h1 id="引用的应用"><a href="#引用的应用" class="headerlink" title="引用的应用"></a>引用的应用</h1><h2 id="1、作为参数"><a href="#1、作为参数" class="headerlink" title="1、作为参数"></a>1、作为参数</h2><p>引用的一个重要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，因为这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是引 用，比起指针，引用不占用任何存储单元，更加高效。<br>引用：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span></span>&#123;    <span class="hljs-keyword">int</span> temp;    temp = a;    a = b;    b = temp; &#125;</code></pre></div><p>指针：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* p1, <span class="hljs-keyword">int</span>* p2)</span></span>&#123;    <span class="hljs-keyword">int</span> temp = *p1;    *p1 = *p2;    *p2 = temp;&#125;</code></pre></div><p>上面使用指针和引用的函数效果一样。</p><h2 id="2、常引用"><a href="#2、常引用" class="headerlink" title="2、常引用"></a>2、常引用</h2><p>常引用声明方式：<code>const int &amp;ra = a；</code></p><p>用这种方式声明的引用，不能通过改变引用而对目标变量进行修改，只能直接修改目标变量的值；</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ra = a;ra = <span class="hljs-number">1</span>; <span class="hljs-comment">//无法修改a的值</span>a = <span class="hljs-number">1</span>；<span class="hljs-comment">//ra=a=1</span></code></pre></div><p>引用型参数应该在能被定义为const的情况下，尽量定义为const；</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">//定义以下函数：</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s)</span></span>;<span class="hljs-comment">//进行如下操作都是非法的</span>bar(foo());bar(<span class="hljs-string">"hello world!"</span>)<span class="hljs-comment">//调用foo()字符串类型函数和使用字符串，C++会创建一个临时const对象，而bar()的形参是string非const类型</span></code></pre></div><h2 id="3、引用作为返回值"><a href="#3、引用作为返回值" class="headerlink" title="3、引用作为返回值"></a>3、引用作为返回值</h2><p><code>类型标识符 &amp;函数名(形参){}</code></p><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><p>（1）以引用返回函数值，定义函数时需要在函数名前加&amp;；</p><p>（2）用引用返回一个函数值最大的好处是，在内存中不会产生返回值的副本，提高效率；</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">fn1</span><span class="hljs-params">(<span class="hljs-keyword">float</span> r)</span> <span class="hljs-comment">//定义函数fn1，它以返回值的方法返回函数值</span></span><span class="hljs-function"></span>&#123;　temp = (<span class="hljs-keyword">float</span>)(r*r*<span class="hljs-number">3.14</span>);　<span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function"><span class="hljs-keyword">float</span> &amp;<span class="hljs-title">fn2</span><span class="hljs-params">(<span class="hljs-keyword">float</span> r)</span> <span class="hljs-comment">//定义函数fn2，它以引用方式返回函数值</span></span><span class="hljs-function"></span>&#123;　temp = (<span class="hljs-keyword">float</span>)(r*r*<span class="hljs-number">3.14</span>);　<span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-comment">//主函数</span></span><span class="hljs-function"></span>&#123;　<span class="hljs-keyword">float</span> a = fn1(<span class="hljs-number">10.0</span>); <span class="hljs-comment">//第1种情况，系统生成要返回值的副本（即临时变量）</span>　<span class="hljs-keyword">float</span> &amp;b = fn1(<span class="hljs-number">10.0</span>);  <span class="hljs-comment">/*第2种情况，可能会出错（不同C++系统有不同规定)不能从被调函数中返回一个临时变量或局部变量的引用*/</span>　<span class="hljs-keyword">float</span> c = fn2(<span class="hljs-number">10.0</span>);   <span class="hljs-comment">//第3种情况，系统不生成返回值的副本可以从被调函数中返回一个全局变量的引用</span>　<span class="hljs-keyword">float</span> &amp;d = fn2(<span class="hljs-number">10.0</span>);  <span class="hljs-comment">//第4种情况，系统不生成返回值的副本可以从被调函数中返回一个全局变量的引用</span>　<span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;c&lt;&lt;d&lt;&lt;<span class="hljs-built_in">endl</span>;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>引用作为返回值，必须遵守以下规则：</p><p>（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。</p><p>（2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。</p><p>（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常 量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</p><p>（4）引用与一些操作符的重载：</p><p>流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; “hello” &lt;&lt; endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回 一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一 个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这 就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。</p><p>测试用返回引用的函数值作为赋值表达式的左值。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> &amp;<span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-keyword">int</span> vals[<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> error=<span class="hljs-number">-1</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">put</span>(<span class="hljs-number">0</span>)=<span class="hljs-number">10</span>; <span class="hljs-comment">//以put(0)函数值作为左值，等价于vals[0]=10;</span><span class="hljs-built_in">put</span>(<span class="hljs-number">9</span>)=<span class="hljs-number">20</span>; <span class="hljs-comment">//以put(9)函数值作为左值，等价于vals[9]=20;</span><span class="hljs-built_in">cout</span>&lt;&lt;vals[<span class="hljs-number">0</span>];<span class="hljs-built_in">cout</span>&lt;&lt;vals[<span class="hljs-number">9</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> &amp;<span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (n&gt;=<span class="hljs-number">0</span> &amp;&amp; n&lt;=<span class="hljs-number">9</span> ) <span class="hljs-keyword">return</span> vals[n];<span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"subscript error"</span>; <span class="hljs-keyword">return</span> error; &#125;&#125;</code></pre></div><p>（5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一 个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。</p><h2 id="4、引用和多态"><a href="#4、引用和多态" class="headerlink" title="4、引用和多态"></a>4、引用和多态</h2><p>引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> 　<span class="hljs-title">A</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> 　<span class="hljs-title">B</span>：<span class="hljs-title">public</span> <span class="hljs-title">A</span>&#123;</span>……&#125;;B 　b;A 　&amp;Ref = b; <span class="hljs-comment">// 用派生类对象初始化基类对象的引用</span></code></pre></div><p>Ref 只能用来访问派生类对象中从基类继承下来的成员，是基类引用指向派生类。如果A类中定义有虚函数，并且在B类中重写了这个虚函数，就可以通过Ref产生多态效果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>（1）在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。</p><p>（2）用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。</p><p>（3）引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。</p><p>（4）使用引用的时机。流操作符&lt;&lt;和&gt;&gt;、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++的引用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客网站搭建教程</title>
    <link href="/2020/06/30/12:28.html"/>
    <url>/2020/06/30/12:28.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#8195;&#8195;最开始是在简书、CSDN、博客园写文章和记笔记，但是有个帖子莫名其妙被删了，加上网站现在的广告太多了，页面很乱很难看，于是就打算自己搭建一个自己的博客网站，拥有所有权，还可以自己定制网站风格。</p><p>&#8195;&#8195;基本原理是：使用Hexo框架生成一个静态页面，Push到GitHub Page、Gitee Pages、Coding Pages上去部署在网络上，在解析到自己购买的域名下，就可以分享给其他人访问了。</p><p>&#8195;&#8195;采用三线部署的原因：GitHub服务器在美国，国内访问速度很慢，国内最快的是Gitee但是想要解析到自定义域名和自动部署都需要花钱，本着白嫖绝不多花钱的心态，Gitee就当作一个备用和备份，国内线路就使用Coding。</p><p>&#8195;&#8195;本来想完完整整自己写教程的，但是太懒了，拖了几天还没开始写，又不想一个个截图，那就直接放链接吧（狗头.png）</p><h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><p>&#8195;&#8195;推荐使用<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode</a>操作。</p><p>&#8195;&#8195;1.<a href="https://zhuanlan.zhihu.com/p/26625249?utm_source=qq&utm_medium=social" target="_blank" rel="noopener">Hexo+GitHub搭建个人网站详细教程</a><strong>注意：仓库名字要和owner名一致才行，如图</strong><img src="https://gitee.com/yossi/picture/raw/master/img/20200701191959.png" srcset="/img/loading.gif" alt="image-20200701191957183"><strong>先不要解析域名，因为这里会有个坑，等coding解析了再去解析github。</strong></p><p>&#8195;&#8195;2.主题推荐Fluid<a href="https://hexo.fluid-dev.com/docs/guide" target="_blank" rel="noopener">搭配完整配置和定制教程</a></p><p>&#8195;&#8195;终端命令行cd进入到blog文件夹：</p><div class="hljs"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid</code></pre></div><p>&#8195;&#8195;3.<a href="https://www.aliyun.com/" target="_blank" rel="noopener">阿里云购买域名</a>建议购买top域名，第一年6元，不需要专属域名的可以不忙购买；</p><p>&#8195;&#8195;4.部署到<a href="https://coding.net/" target="_blank" rel="noopener">Coding</a>上去，<a href="https://blog.wubin.design/archives/43.html" target="_blank" rel="noopener">新版coding搭建个人博客教程</a>只看前三步。</p><p>&#8195;&#8195;5.部署到<a href="https://gitee.com/" target="_blank" rel="noopener">Gitee</a>，操作过程和GitHub是一样的，设置SSH–&gt;建仓库(记住仓库名字要和owner一致)</p><p>&#8195;&#8195;6.打开blog文件夹下的<strong>_config.yml</strong>文件，拉到最下面，修改配置如下：</p><div class="hljs"><pre><code class="hljs crmsh">deploy:  <span class="hljs-keyword">type</span>: git  repo:     github: 你的github clone地址,<span class="hljs-literal">master</span>    coding: 你的Coding clone地址,<span class="hljs-literal">master</span>    gitee: 你的gitee clone地址,<span class="hljs-literal">master</span></code></pre></div><p>&#8195;&#8195;7.现在去解析域名，记住先解析coding的申请获得证书后，再去添加解析GitHub的，具体操作在1、4步骤里面，不懂的再留言回答；</p><h2 id="迷迷糊糊？简单介绍Hexo-init的这个文件夹，方便后续定制化"><a href="#迷迷糊糊？简单介绍Hexo-init的这个文件夹，方便后续定制化" class="headerlink" title="迷迷糊糊？简单介绍Hexo init的这个文件夹，方便后续定制化"></a>迷迷糊糊？简单介绍Hexo init的这个文件夹，方便后续定制化</h2><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200701194940.png" srcset="/img/loading.gif" alt="image-20200701194933305"></p><hr><p>&#8195;&#8195;<strong>_config.yml</strong>是blog的整体配置文件，这种配置文件在<strong>themes–&gt;fluid</strong>里面也存在，定制自己的网站就是在这里修改相关配置；</p><p>&#8195;&#8195;<strong>source</strong>存放各种资源，例如你的文章，插图等，<strong>source–&gt;_post</strong>存放的是你的文章，<strong>Hexo new “新文章”</strong>就会在此文件夹生成相应的<strong>.MD</strong>格式文件；</p><p>&#8195;&#8195;<strong>public</strong>就是<code>Hexo g</code>生成的静态网页文件夹，<strong>Push</strong>到github仓库的就是这个文件夹；</p><hr><p><strong>themes–&gt;fluid</strong>下的文件</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200701195935.png" srcset="/img/loading.gif" alt="image-20200701195933635"></p><p>&#8195;&#8195;<strong>_config.yml</strong>是主题的配置文件；</p><p>&#8195;&#8195;<strong>layout</strong>是页面布局，定制化的时候修改页面布局在这里面的源文件修改代码；</p><h1 id="typora-picgo-gitee搭建免费图床"><a href="#typora-picgo-gitee搭建免费图床" class="headerlink" title="typora+picgo+gitee搭建免费图床"></a>typora+picgo+gitee搭建免费图床</h1><h2 id="为什么需要图床？"><a href="#为什么需要图床？" class="headerlink" title="为什么需要图床？"></a>为什么需要图床？</h2><p>&#8195;&#8195;如果你把所有图片都放在<strong>source</strong>里面去调用的话，其他人加载你网页的时候就会特别慢，图床就是你的网络图库，在文章添加图片链接调用图片会加快网页加载速度。</p><h2 id="白嫖教程开始"><a href="#白嫖教程开始" class="headerlink" title="白嫖教程开始"></a>白嫖教程开始</h2><p>上链接<a href="https://blog.csdn.net/wugenqiang/article/details/105644905" target="_blank" rel="noopener">typora+picgo+gitee白嫖图床</a></p><p>超链接真是伟大的发明[旺柴]</p>]]></content>
    
    
    <categories>
      
      <category>hexo搭建教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid，picgo，typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客网站折腾日记（一）</title>
    <link href="/2020/06/27/16:45.html"/>
    <url>/2020/06/27/16:45.html</url>
    
    <content type="html"><![CDATA[<h1 id="明天再来写今天踩的坑"><a href="#明天再来写今天踩的坑" class="headerlink" title="明天再来写今天踩的坑"></a>明天再来写今天踩的坑</h1><p>​&#8195;&#8195;Github Pages 今天又抽筋访问速度及其慢，跟着教程使用多线路网站部署，然而Coding网站大改，使用习惯和其他Git网站不一样，不太习惯，gitee自定义域名和自动部署上线都要充会员，没办法，当作备用吧，gitee本站备用地址：<a href="https://yossi.gitee.io/" target="_blank" rel="noopener">https://yossi.gitee.io/</a></p><p>&#8195;&#8195;国外走Github线路，国内走Coding线路，访问速度终于上去了。</p><p>&#8195;&#8195;Coding pages强制https协议出错，明天再来查是哪儿出问题了，目前使用的是http协议上线。</p><h2 id="关于Coding-Pages-强制https协议失败的原因"><a href="#关于Coding-Pages-强制https协议失败的原因" class="headerlink" title="关于Coding Pages 强制https协议失败的原因"></a>关于Coding Pages 强制https协议失败的原因</h2><p>&#8195;&#8195;是我的Coding pages域名证书申请失败了，因为我阿里云DNS域名解析先绑定的github pages并且打开了https协议，所以在Coding pages里面申请域名证书验证域名所有权时，会定位到已经有SSL证书的Github Pages 的主机上，导致Coding的SSL证书申请失败。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>&#8195;&#8195;先去域名DNS解析控制台把GitHub Pages 的解析暂停，然后重新申请Coding Pages的证书，就可以打开强制https了。</p><p>​&#8195;&#8195;注意：今后在写博客引用资源的时候，要注意所有的网络资源URL必须上https协议开头的，不然浏览器会提示网站不安全无法打开。</p>]]></content>
    
    
    <categories>
      
      <category>hexo搭建教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些坑</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
