<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++的引用与指针的区别</title>
    <link href="/2020/07/03/C++%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <url>/2020/07/03/C++%E7%9A%84%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>引用(&amp;)是对某个<strong>变量</strong>取一个别名，对引用对操作和直接操作<strong>变量</strong>效果一样；</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;   <span class="hljs-keyword">int</span> a;   <span class="hljs-keyword">int</span> &amp;ra = a;    ra = <span class="hljs-number">1</span>;   <span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;ra&lt;&lt;<span class="hljs-built_in">endl</span>;   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>结果：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-number">1</span> <span class="hljs-number">1</span></code></pre></div><p>指针(*)是对某个<strong>变量</strong>的地址变量，对地址内容进行操作和直接操作<strong>变量</strong>效果一样；</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> a;    <span class="hljs-keyword">int</span>* p = &amp;a;    *p = <span class="hljs-number">1</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre></div><p>结果：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-number">1</span></code></pre></div><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>(0) <strong>声明一个引用，不是定义了一个新变量，只是一个别名，所以它本身不是一种数据类型，不会占用内存，但是指针属于指针变量，会占用内存，这就是引用的优点。使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效 率和所占空间都好。使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用”*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</strong><br>(1) &amp;在此不是求地址运算符，而是引用标识符；<br>(2) 声明引用时，必须同时对其初始化；<br>(3) 使用引用后，相当于变量内存上有两个变量名，<code>ra=1</code>等价于<code>a=1</code>而使用指针是指针变量指向变量地址<code>*p=1</code>等价于<code>a=1</code>；  </p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200703104540.png" srcset="/img/loading.gif" alt="image-20200703104539112"><br>(4) 不能建立数组的引用，因为数组是由若干个元素所组成的集合，无法创建一个数组的别名；  </p><h1 id="引用的应用"><a href="#引用的应用" class="headerlink" title="引用的应用"></a>引用的应用</h1><h2 id="1、作为参数"><a href="#1、作为参数" class="headerlink" title="1、作为参数"></a>1、作为参数</h2><p>引用的一个重要作用就是作为函数的参数。以前的C语言中函数参数传递是值传递，如果有大块数据作为参数传递的时候，采用的方案往往是指针，因为这样可以避免将整块数据全部压栈，可以提高程序的效率。但是现在（C++中）又增加了一种同样有效率的选择（在某些特殊情况下又是必须的选择），就是引 用，比起指针，引用不占用任何存储单元，更加高效。<br>引用：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;a, <span class="hljs-keyword">int</span> &amp;b)</span></span>&#123;    <span class="hljs-keyword">int</span> temp;    temp = a;    a = b;    b = temp; &#125;</code></pre></div><p>指针：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* p1, <span class="hljs-keyword">int</span>* p2)</span></span>&#123;    <span class="hljs-keyword">int</span> temp = *p1;    *p1 = *p2;    *p2 = temp;&#125;</code></pre></div><p>上面使用指针和引用的函数效果一样。</p><h2 id="2、常引用"><a href="#2、常引用" class="headerlink" title="2、常引用"></a>2、常引用</h2><p>常引用声明方式：<code>const int &amp;ra = a；</code></p><p>用这种方式声明的引用，不能通过改变引用而对目标变量进行修改，只能直接修改目标变量的值；</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> a;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> &amp;ra = a;ra = <span class="hljs-number">1</span>; <span class="hljs-comment">//无法修改a的值</span>a = <span class="hljs-number">1</span>；<span class="hljs-comment">//ra=a=1</span></code></pre></div><p>引用型参数应该在能被定义为const的情况下，尽量定义为const；</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">//定义以下函数：</span><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-built_in">string</span> &amp;s)</span></span>;<span class="hljs-comment">//进行如下操作都是非法的</span>bar(foo());bar(<span class="hljs-string">"hello world!"</span>)<span class="hljs-comment">//调用foo()字符串类型函数和使用字符串，C++会创建一个临时const对象，而bar()的形参是string非const类型</span></code></pre></div><h2 id="3、引用作为返回值"><a href="#3、引用作为返回值" class="headerlink" title="3、引用作为返回值"></a>3、引用作为返回值</h2><p><code>类型标识符 &amp;函数名(形参){}</code></p><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><p>（1）以引用返回函数值，定义函数时需要在函数名前加&amp;；</p><p>（2）用引用返回一个函数值最大的好处是，在内存中不会产生返回值的副本，提高效率；</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">fn1</span><span class="hljs-params">(<span class="hljs-keyword">float</span> r)</span> <span class="hljs-comment">//定义函数fn1，它以返回值的方法返回函数值</span></span><span class="hljs-function"></span>&#123;　temp = (<span class="hljs-keyword">float</span>)(r*r*<span class="hljs-number">3.14</span>);　<span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function"><span class="hljs-keyword">float</span> &amp;<span class="hljs-title">fn2</span><span class="hljs-params">(<span class="hljs-keyword">float</span> r)</span> <span class="hljs-comment">//定义函数fn2，它以引用方式返回函数值</span></span><span class="hljs-function"></span>&#123;　temp = (<span class="hljs-keyword">float</span>)(r*r*<span class="hljs-number">3.14</span>);　<span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> <span class="hljs-comment">//主函数</span></span><span class="hljs-function"></span>&#123;　<span class="hljs-keyword">float</span> a = fn1(<span class="hljs-number">10.0</span>); <span class="hljs-comment">//第1种情况，系统生成要返回值的副本（即临时变量）</span>　<span class="hljs-keyword">float</span> &amp;b = fn1(<span class="hljs-number">10.0</span>);  <span class="hljs-comment">/*第2种情况，可能会出错（不同C++系统有不同规定)不能从被调函数中返回一个临时变量或局部变量的引用*/</span>　<span class="hljs-keyword">float</span> c = fn2(<span class="hljs-number">10.0</span>);   <span class="hljs-comment">//第3种情况，系统不生成返回值的副本可以从被调函数中返回一个全局变量的引用</span>　<span class="hljs-keyword">float</span> &amp;d = fn2(<span class="hljs-number">10.0</span>);  <span class="hljs-comment">//第4种情况，系统不生成返回值的副本可以从被调函数中返回一个全局变量的引用</span>　<span class="hljs-built_in">cout</span>&lt;&lt;a&lt;&lt;c&lt;&lt;d&lt;&lt;<span class="hljs-built_in">endl</span>;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>引用作为返回值，必须遵守以下规则：</p><p>（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了”无所指”的引用，程序会进入未知状态。</p><p>（2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。</p><p>（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常 量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</p><p>（4）引用与一些操作符的重载：</p><p>流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; “hello” &lt;&lt; endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回 一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。对于返回一 个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这 就是C++语言中引入引用这个概念的原因吧。 赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。</p><p>测试用返回引用的函数值作为赋值表达式的左值。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> &amp;<span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;<span class="hljs-keyword">int</span> vals[<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> error=<span class="hljs-number">-1</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-built_in">put</span>(<span class="hljs-number">0</span>)=<span class="hljs-number">10</span>; <span class="hljs-comment">//以put(0)函数值作为左值，等价于vals[0]=10;</span><span class="hljs-built_in">put</span>(<span class="hljs-number">9</span>)=<span class="hljs-number">20</span>; <span class="hljs-comment">//以put(9)函数值作为左值，等价于vals[9]=20;</span><span class="hljs-built_in">cout</span>&lt;&lt;vals[<span class="hljs-number">0</span>];<span class="hljs-built_in">cout</span>&lt;&lt;vals[<span class="hljs-number">9</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> &amp;<span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (n&gt;=<span class="hljs-number">0</span> &amp;&amp; n&lt;=<span class="hljs-number">9</span> ) <span class="hljs-keyword">return</span> vals[n];<span class="hljs-keyword">else</span> &#123; <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"subscript error"</span>; <span class="hljs-keyword">return</span> error; &#125;&#125;</code></pre></div><p>（5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一 个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。</p><h2 id="4、引用和多态"><a href="#4、引用和多态" class="headerlink" title="4、引用和多态"></a>4、引用和多态</h2><p>引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> 　<span class="hljs-title">A</span>;</span><span class="hljs-class"><span class="hljs-keyword">class</span> 　<span class="hljs-title">B</span>：<span class="hljs-title">public</span> <span class="hljs-title">A</span>&#123;</span>……&#125;;B 　b;A 　&amp;Ref = b; <span class="hljs-comment">// 用派生类对象初始化基类对象的引用</span></code></pre></div><p>Ref 只能用来访问派生类对象中从基类继承下来的成员，是基类引用指向派生类。如果A类中定义有虚函数，并且在B类中重写了这个虚函数，就可以通过Ref产生多态效果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>（1）在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。</p><p>（2）用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。</p><p>（3）引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。</p><p>（4）使用引用的时机。流操作符&lt;&lt;和&gt;&gt;、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++的引用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客网站搭建教程</title>
    <link href="/2020/06/30/hexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <url>/2020/06/30/hexo%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&#8195;&#8195;最开始是在简书、CSDN、博客园写文章和记笔记，但是有个帖子莫名其妙被删了，加上网站现在的广告太多了，页面很乱很难看，于是就打算自己搭建一个自己的博客网站，拥有所有权，还可以自己定制网站风格。</p><p>&#8195;&#8195;基本原理是：使用Hexo框架生成一个静态页面，Push到GitHub Page、Gitee Pages、Coding Pages上去部署在网络上，在解析到自己购买的域名下，就可以分享给其他人访问了。</p><p>&#8195;&#8195;采用三线部署的原因：GitHub服务器在美国，国内访问速度很慢，国内最快的是Gitee但是想要解析到自定义域名和自动部署都需要花钱，本着白嫖绝不多花钱的心态，Gitee就当作一个备用和备份，国内线路就使用Coding。</p><p>&#8195;&#8195;本来想完完整整自己写教程的，但是太懒了，拖了几天还没开始写，又不想一个个截图，那就直接放链接吧（狗头.png）</p><h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><p>&#8195;&#8195;推荐使用<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">vscode</a>操作。</p><p>&#8195;&#8195;1.<a href="https://zhuanlan.zhihu.com/p/26625249?utm_source=qq&utm_medium=social" target="_blank" rel="noopener">Hexo+GitHub搭建个人网站详细教程</a><strong>注意：仓库名字要和owner名一致才行，如图</strong><img src="https://gitee.com/yossi/picture/raw/master/img/20200701191959.png" srcset="/img/loading.gif" alt="image-20200701191957183"><strong>先不要解析域名，因为这里会有个坑，等coding解析了再去解析github。</strong></p><p>&#8195;&#8195;2.主题推荐Fluid<a href="https://hexo.fluid-dev.com/docs/guide" target="_blank" rel="noopener">搭配完整配置和定制教程</a></p><p>&#8195;&#8195;终端命令行cd进入到blog文件夹：</p><div class="hljs"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/fluid-dev/hexo-theme-fluid.git themes/fluid</code></pre></div><p>&#8195;&#8195;3.<a href="https://www.aliyun.com/" target="_blank" rel="noopener">阿里云购买域名</a>建议购买top域名，第一年6元，不需要专属域名的可以不忙购买；</p><p>&#8195;&#8195;4.部署到<a href="https://coding.net/" target="_blank" rel="noopener">Coding</a>上去，<a href="https://blog.wubin.design/archives/43.html" target="_blank" rel="noopener">新版coding搭建个人博客教程</a>只看前三步。</p><p>&#8195;&#8195;5.部署到<a href="https://gitee.com/" target="_blank" rel="noopener">Gitee</a>，操作过程和GitHub是一样的，设置SSH–&gt;建仓库(记住仓库名字要和owner一致)</p><p>&#8195;&#8195;6.打开blog文件夹下的<strong>_config.yml</strong>文件，拉到最下面，修改配置如下：</p><div class="hljs"><pre><code class="hljs crmsh">deploy:  <span class="hljs-keyword">type</span>: git  repo:     github: 你的github clone地址,<span class="hljs-literal">master</span>    coding: 你的Coding clone地址,<span class="hljs-literal">master</span>    gitee: 你的gitee clone地址,<span class="hljs-literal">master</span></code></pre></div><p>&#8195;&#8195;7.现在去解析域名，记住先解析coding的申请获得证书后，再去添加解析GitHub的，具体操作在1、4步骤里面，不懂的再留言回答；</p><h2 id="迷迷糊糊？简单介绍Hexo-init的这个文件夹，方便后续定制化"><a href="#迷迷糊糊？简单介绍Hexo-init的这个文件夹，方便后续定制化" class="headerlink" title="迷迷糊糊？简单介绍Hexo init的这个文件夹，方便后续定制化"></a>迷迷糊糊？简单介绍Hexo init的这个文件夹，方便后续定制化</h2><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200701194940.png" srcset="/img/loading.gif" alt="image-20200701194933305"></p><hr><p>&#8195;&#8195;<strong>_config.yml</strong>是blog的整体配置文件，这种配置文件在<strong>themes–&gt;fluid</strong>里面也存在，定制自己的网站就是在这里修改相关配置；</p><p>&#8195;&#8195;<strong>source</strong>存放各种资源，例如你的文章，插图等，<strong>source–&gt;_post</strong>存放的是你的文章，<strong>Hexo new “新文章”</strong>就会在此文件夹生成相应的<strong>.MD</strong>格式文件；</p><p>&#8195;&#8195;<strong>public</strong>就是<code>Hexo g</code>生成的静态网页文件夹，<strong>Push</strong>到github仓库的就是这个文件夹；</p><hr><p><strong>themes–&gt;fluid</strong>下的文件</p><p><img src="https://gitee.com/yossi/picture/raw/master/img/20200701195935.png" srcset="/img/loading.gif" alt="image-20200701195933635"></p><p>&#8195;&#8195;<strong>_config.yml</strong>是主题的配置文件；</p><p>&#8195;&#8195;<strong>layout</strong>是页面布局，定制化的时候修改页面布局在这里面的源文件修改代码；</p><h1 id="typora-picgo-gitee搭建免费图床"><a href="#typora-picgo-gitee搭建免费图床" class="headerlink" title="typora+picgo+gitee搭建免费图床"></a>typora+picgo+gitee搭建免费图床</h1><h2 id="为什么需要图床？"><a href="#为什么需要图床？" class="headerlink" title="为什么需要图床？"></a>为什么需要图床？</h2><p>&#8195;&#8195;如果你把所有图片都放在<strong>source</strong>里面去调用的话，其他人加载你网页的时候就会特别慢，图床就是你的网络图库，在文章添加图片链接调用图片会加快网页加载速度。</p><h2 id="白嫖教程开始"><a href="#白嫖教程开始" class="headerlink" title="白嫖教程开始"></a>白嫖教程开始</h2><p>上链接<a href="https://blog.csdn.net/wugenqiang/article/details/105644905" target="_blank" rel="noopener">typora+picgo+gitee白嫖图床</a></p><p>超链接真是伟大的发明[旺柴]</p>]]></content>
    
    
    <categories>
      
      <category>hexo搭建教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid，picgo，typora</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客网站折腾日记（一）</title>
    <link href="/2020/06/27/first/"/>
    <url>/2020/06/27/first/</url>
    
    <content type="html"><![CDATA[<h1 id="明天再来写今天踩的坑"><a href="#明天再来写今天踩的坑" class="headerlink" title="明天再来写今天踩的坑"></a>明天再来写今天踩的坑</h1><p>​&#8195;&#8195;Github Pages 今天又抽筋访问速度及其慢，跟着教程使用多线路网站部署，然而Coding网站大改，使用习惯和其他Git网站不一样，不太习惯，gitee自定义域名和自动部署上线都要充会员，没办法，当作备用吧，gitee本站备用地址：<a href="https://yossi.gitee.io/" target="_blank" rel="noopener">https://yossi.gitee.io/</a></p><p>&#8195;&#8195;国外走Github线路，国内走Coding线路，访问速度终于上去了。</p><p>&#8195;&#8195;Coding pages强制https协议出错，明天再来查是哪儿出问题了，目前使用的是http协议上线。</p><h2 id="关于Coding-Pages-强制https协议失败的原因"><a href="#关于Coding-Pages-强制https协议失败的原因" class="headerlink" title="关于Coding Pages 强制https协议失败的原因"></a>关于Coding Pages 强制https协议失败的原因</h2><p>&#8195;&#8195;是我的Coding pages域名证书申请失败了，因为我阿里云DNS域名解析先绑定的github pages并且打开了https协议，所以在Coding pages里面申请域名证书验证域名所有权时，会定位到已经有SSL证书的Github Pages 的主机上，导致Coding的SSL证书申请失败。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>&#8195;&#8195;先去域名DNS解析控制台把GitHub Pages 的解析暂停，然后重新申请Coding Pages的证书，就可以打开强制https了。</p><p>​&#8195;&#8195;注意：今后在写博客引用资源的时候，要注意所有的网络资源URL必须上https协议开头的，不然浏览器会提示网站不安全无法打开。</p>]]></content>
    
    
    <categories>
      
      <category>hexo搭建教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>一些坑</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
